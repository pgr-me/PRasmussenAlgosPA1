 --- modulename: __main__, funcname: <module>
__main__.py(1): """Peter Rasmussen, Programming Assignment 1, __main__.py
__main__.py(23): import argparse
__main__.py(24): from pathlib import Path
__main__.py(25): import sys
__main__.py(28): from pa1.run import run
__main__.py(31): sys.setrecursionlimit(16000)
__main__.py(35): parser = argparse.ArgumentParser()
 --- modulename: argparse, funcname: __init__
argparse.py(1652):         superinit = super(ArgumentParser, self).__init__
argparse.py(1653):         superinit(description=description,
argparse.py(1654):                   prefix_chars=prefix_chars,
argparse.py(1655):                   argument_default=argument_default,
argparse.py(1656):                   conflict_handler=conflict_handler)
argparse.py(1653):         superinit(description=description,
 --- modulename: argparse, funcname: __init__
argparse.py(1260):         super(_ActionsContainer, self).__init__()
argparse.py(1262):         self.description = description
argparse.py(1263):         self.argument_default = argument_default
argparse.py(1264):         self.prefix_chars = prefix_chars
argparse.py(1265):         self.conflict_handler = conflict_handler
argparse.py(1268):         self._registries = {}
argparse.py(1271):         self.register('action', None, _StoreAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1272):         self.register('action', 'store', _StoreAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1273):         self.register('action', 'store_const', _StoreConstAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1274):         self.register('action', 'store_true', _StoreTrueAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1275):         self.register('action', 'store_false', _StoreFalseAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1276):         self.register('action', 'append', _AppendAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1277):         self.register('action', 'append_const', _AppendConstAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1278):         self.register('action', 'count', _CountAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1279):         self.register('action', 'help', _HelpAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1280):         self.register('action', 'version', _VersionAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1281):         self.register('action', 'parsers', _SubParsersAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1282):         self.register('action', 'extend', _ExtendAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1285):         self._get_handler()
 --- modulename: argparse, funcname: _get_handler
argparse.py(1520):         handler_func_name = '_handle_conflict_%s' % self.conflict_handler
argparse.py(1521):         try:
argparse.py(1522):             return getattr(self, handler_func_name)
argparse.py(1288):         self._actions = []
argparse.py(1289):         self._option_string_actions = {}
argparse.py(1292):         self._action_groups = []
argparse.py(1293):         self._mutually_exclusive_groups = []
argparse.py(1296):         self._defaults = {}
argparse.py(1299):         self._negative_number_matcher = _re.compile(r'^-\d+$|^-\d*\.\d+$')
 --- modulename: re, funcname: compile
re.py(252):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
argparse.py(1303):         self._has_negative_number_optionals = []
argparse.py(1659):         if prog is None:
argparse.py(1660):             prog = _os.path.basename(_sys.argv[0])
 --- modulename: posixpath, funcname: basename
posixpath.py(142):     p = os.fspath(p)
posixpath.py(143):     sep = _get_sep(p)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(144):     i = p.rfind(sep) + 1
posixpath.py(145):     return p[i:]
argparse.py(1662):         self.prog = prog
argparse.py(1663):         self.usage = usage
argparse.py(1664):         self.epilog = epilog
argparse.py(1665):         self.formatter_class = formatter_class
argparse.py(1666):         self.fromfile_prefix_chars = fromfile_prefix_chars
argparse.py(1667):         self.add_help = add_help
argparse.py(1668):         self.allow_abbrev = allow_abbrev
argparse.py(1670):         add_group = self.add_argument_group
argparse.py(1671):         self._positionals = add_group(_('positional arguments'))
 --- modulename: gettext, funcname: gettext
gettext.py(736):     return dgettext(_current_domain, message)
 --- modulename: gettext, funcname: dgettext
gettext.py(661):     try:
gettext.py(662):         t = translation(domain, _localedirs.get(domain, None))
 --- modulename: gettext, funcname: translation
gettext.py(581):     if class_ is None:
gettext.py(582):         class_ = GNUTranslations
gettext.py(583):     mofiles = find(domain, localedir, languages, all=True)
 --- modulename: gettext, funcname: find
gettext.py(540):     if localedir is None:
gettext.py(541):         localedir = _default_localedir
gettext.py(542):     if languages is None:
gettext.py(543):         languages = []
gettext.py(544):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(545):             val = os.environ.get(envar)
 --- modulename: _collections_abc, funcname: get
_collections_abc.py(659):         try:
_collections_abc.py(660):             return self[key]
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
_collections_abc.py(661):         except KeyError:
_collections_abc.py(662):             return default
gettext.py(546):             if val:
gettext.py(544):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(545):             val = os.environ.get(envar)
 --- modulename: _collections_abc, funcname: get
_collections_abc.py(659):         try:
_collections_abc.py(660):             return self[key]
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
_collections_abc.py(661):         except KeyError:
_collections_abc.py(662):             return default
gettext.py(546):             if val:
gettext.py(544):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(545):             val = os.environ.get(envar)
 --- modulename: _collections_abc, funcname: get
_collections_abc.py(659):         try:
_collections_abc.py(660):             return self[key]
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
_collections_abc.py(661):         except KeyError:
_collections_abc.py(662):             return default
gettext.py(546):             if val:
gettext.py(544):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(545):             val = os.environ.get(envar)
 --- modulename: _collections_abc, funcname: get
_collections_abc.py(659):         try:
_collections_abc.py(660):             return self[key]
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(676):         return self.decodevalue(value)
 --- modulename: os, funcname: decode
os.py(753):             return value.decode(encoding, 'surrogateescape')
gettext.py(546):             if val:
gettext.py(547):                 languages = val.split(':')
gettext.py(548):                 break
gettext.py(549):         if 'C' not in languages:
gettext.py(550):             languages.append('C')
gettext.py(552):     nelangs = []
gettext.py(553):     for lang in languages:
gettext.py(554):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(213):     loc = locale.normalize(loc)
 --- modulename: locale, funcname: normalize
locale.py(401):     code = localename.lower()
locale.py(402):     if ':' in code:
locale.py(405):     if '@' in code:
locale.py(408):         modifier = ''
locale.py(409):     if '.' in code:
locale.py(410):         langname, encoding = code.split('.')[:2]
locale.py(416):     lang_enc = langname
locale.py(417):     if encoding:
locale.py(418):         norm_encoding = encoding.replace('-', '')
locale.py(419):         norm_encoding = norm_encoding.replace('_', '')
locale.py(420):         lang_enc += '.' + norm_encoding
locale.py(421):     lookup_name = lang_enc
locale.py(422):     if modifier:
locale.py(424):     code = locale_alias.get(lookup_name, None)
locale.py(425):     if code is not None:
locale.py(429):     if modifier:
locale.py(440):     if encoding:
locale.py(442):         lookup_name = langname
locale.py(443):         if modifier:
locale.py(445):         code = locale_alias.get(lookup_name, None)
locale.py(446):         if code is not None:
locale.py(448):             if '@' not in code:
locale.py(449):                 return _replace_encoding(code, encoding)
 --- modulename: locale, funcname: _replace_encoding
locale.py(351):     if '.' in code:
locale.py(352):         langname = code[:code.index('.')]
locale.py(356):     norm_encoding = encodings.normalize_encoding(encoding)
 --- modulename: __init__, funcname: normalize_encoding
__init__.py(55):     if isinstance(encoding, bytes):
__init__.py(58):     chars = []
__init__.py(59):     punct = False
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(62):             if punct and chars:
__init__.py(64):             chars.append(c)
__init__.py(65):             punct = False
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(62):             if punct and chars:
__init__.py(64):             chars.append(c)
__init__.py(65):             punct = False
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(62):             if punct and chars:
__init__.py(64):             chars.append(c)
__init__.py(65):             punct = False
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(67):             punct = True
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(62):             if punct and chars:
__init__.py(63):                 chars.append('_')
__init__.py(64):             chars.append(c)
__init__.py(65):             punct = False
__init__.py(60):     for c in encoding:
__init__.py(68):     return ''.join(chars)
locale.py(358):     norm_encoding = encodings.aliases.aliases.get(norm_encoding.lower(),
locale.py(359):                                                   norm_encoding)
locale.py(358):     norm_encoding = encodings.aliases.aliases.get(norm_encoding.lower(),
locale.py(361):     encoding = norm_encoding
locale.py(362):     norm_encoding = norm_encoding.lower()
locale.py(363):     if norm_encoding in locale_encoding_alias:
locale.py(364):         encoding = locale_encoding_alias[norm_encoding]
locale.py(371):     return langname + '.' + encoding
gettext.py(214):     COMPONENT_CODESET   = 1 << 0
gettext.py(215):     COMPONENT_TERRITORY = 1 << 1
gettext.py(216):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(218):     mask = 0
gettext.py(219):     pos = loc.find('@')
gettext.py(220):     if pos >= 0:
gettext.py(225):         modifier = ''
gettext.py(226):     pos = loc.find('.')
gettext.py(227):     if pos >= 0:
gettext.py(228):         codeset = loc[pos:]
gettext.py(229):         loc = loc[:pos]
gettext.py(230):         mask |= COMPONENT_CODESET
gettext.py(233):     pos = loc.find('_')
gettext.py(234):     if pos >= 0:
gettext.py(235):         territory = loc[pos:]
gettext.py(236):         loc = loc[:pos]
gettext.py(237):         mask |= COMPONENT_TERRITORY
gettext.py(240):     language = loc
gettext.py(241):     ret = []
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(249):     ret.reverse()
gettext.py(250):     return ret
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(553):     for lang in languages:
gettext.py(554):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(213):     loc = locale.normalize(loc)
 --- modulename: locale, funcname: normalize
locale.py(401):     code = localename.lower()
locale.py(402):     if ':' in code:
locale.py(405):     if '@' in code:
locale.py(408):         modifier = ''
locale.py(409):     if '.' in code:
locale.py(412):         langname = code
locale.py(413):         encoding = ''
locale.py(416):     lang_enc = langname
locale.py(417):     if encoding:
locale.py(421):     lookup_name = lang_enc
locale.py(422):     if modifier:
locale.py(424):     code = locale_alias.get(lookup_name, None)
locale.py(425):     if code is not None:
locale.py(426):         return code
gettext.py(214):     COMPONENT_CODESET   = 1 << 0
gettext.py(215):     COMPONENT_TERRITORY = 1 << 1
gettext.py(216):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(218):     mask = 0
gettext.py(219):     pos = loc.find('@')
gettext.py(220):     if pos >= 0:
gettext.py(225):         modifier = ''
gettext.py(226):     pos = loc.find('.')
gettext.py(227):     if pos >= 0:
gettext.py(232):         codeset = ''
gettext.py(233):     pos = loc.find('_')
gettext.py(234):     if pos >= 0:
gettext.py(239):         territory = ''
gettext.py(240):     language = loc
gettext.py(241):     ret = []
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(249):     ret.reverse()
gettext.py(250):     return ret
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(553):     for lang in languages:
gettext.py(558):     if all:
gettext.py(559):         result = []
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(565):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
gettext.py(566):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(18):     try:
genericpath.py(19):         os.stat(path)
genericpath.py(20):     except (OSError, ValueError):
genericpath.py(21):         return False
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(565):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
gettext.py(566):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(18):     try:
genericpath.py(19):         os.stat(path)
genericpath.py(20):     except (OSError, ValueError):
genericpath.py(21):         return False
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(565):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
gettext.py(566):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(18):     try:
genericpath.py(19):         os.stat(path)
genericpath.py(20):     except (OSError, ValueError):
genericpath.py(21):         return False
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(565):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
gettext.py(566):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(18):     try:
genericpath.py(19):         os.stat(path)
genericpath.py(20):     except (OSError, ValueError):
genericpath.py(21):         return False
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(564):             break
gettext.py(571):     return result
gettext.py(584):     if not mofiles:
gettext.py(585):         if fallback:
gettext.py(587):         from errno import ENOENT
gettext.py(588):         raise FileNotFoundError(ENOENT,
gettext.py(589):                                 'No translation file found for domain', domain)
gettext.py(588):         raise FileNotFoundError(ENOENT,
gettext.py(663):     except OSError:
gettext.py(664):         return message
 --- modulename: argparse, funcname: add_argument_group
argparse.py(1389):         group = _ArgumentGroup(self, *args, **kwargs)
 --- modulename: argparse, funcname: __init__
argparse.py(1569):         update = kwargs.setdefault
argparse.py(1570):         update('conflict_handler', container.conflict_handler)
argparse.py(1571):         update('prefix_chars', container.prefix_chars)
argparse.py(1572):         update('argument_default', container.argument_default)
argparse.py(1573):         super_init = super(_ArgumentGroup, self).__init__
argparse.py(1574):         super_init(description=description, **kwargs)
 --- modulename: argparse, funcname: __init__
argparse.py(1260):         super(_ActionsContainer, self).__init__()
argparse.py(1262):         self.description = description
argparse.py(1263):         self.argument_default = argument_default
argparse.py(1264):         self.prefix_chars = prefix_chars
argparse.py(1265):         self.conflict_handler = conflict_handler
argparse.py(1268):         self._registries = {}
argparse.py(1271):         self.register('action', None, _StoreAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1272):         self.register('action', 'store', _StoreAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1273):         self.register('action', 'store_const', _StoreConstAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1274):         self.register('action', 'store_true', _StoreTrueAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1275):         self.register('action', 'store_false', _StoreFalseAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1276):         self.register('action', 'append', _AppendAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1277):         self.register('action', 'append_const', _AppendConstAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1278):         self.register('action', 'count', _CountAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1279):         self.register('action', 'help', _HelpAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1280):         self.register('action', 'version', _VersionAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1281):         self.register('action', 'parsers', _SubParsersAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1282):         self.register('action', 'extend', _ExtendAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1285):         self._get_handler()
 --- modulename: argparse, funcname: _get_handler
argparse.py(1520):         handler_func_name = '_handle_conflict_%s' % self.conflict_handler
argparse.py(1521):         try:
argparse.py(1522):             return getattr(self, handler_func_name)
argparse.py(1288):         self._actions = []
argparse.py(1289):         self._option_string_actions = {}
argparse.py(1292):         self._action_groups = []
argparse.py(1293):         self._mutually_exclusive_groups = []
argparse.py(1296):         self._defaults = {}
argparse.py(1299):         self._negative_number_matcher = _re.compile(r'^-\d+$|^-\d*\.\d+$')
 --- modulename: re, funcname: compile
re.py(252):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
argparse.py(1303):         self._has_negative_number_optionals = []
argparse.py(1577):         self.title = title
argparse.py(1578):         self._group_actions = []
argparse.py(1581):         self._registries = container._registries
argparse.py(1582):         self._actions = container._actions
argparse.py(1583):         self._option_string_actions = container._option_string_actions
argparse.py(1584):         self._defaults = container._defaults
argparse.py(1586):             container._has_negative_number_optionals
argparse.py(1585):         self._has_negative_number_optionals = \
argparse.py(1587):         self._mutually_exclusive_groups = container._mutually_exclusive_groups
argparse.py(1390):         self._action_groups.append(group)
argparse.py(1391):         return group
argparse.py(1672):         self._optionals = add_group(_('optional arguments'))
 --- modulename: gettext, funcname: gettext
gettext.py(736):     return dgettext(_current_domain, message)
 --- modulename: gettext, funcname: dgettext
gettext.py(661):     try:
gettext.py(662):         t = translation(domain, _localedirs.get(domain, None))
 --- modulename: gettext, funcname: translation
gettext.py(581):     if class_ is None:
gettext.py(582):         class_ = GNUTranslations
gettext.py(583):     mofiles = find(domain, localedir, languages, all=True)
 --- modulename: gettext, funcname: find
gettext.py(540):     if localedir is None:
gettext.py(541):         localedir = _default_localedir
gettext.py(542):     if languages is None:
gettext.py(543):         languages = []
gettext.py(544):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(545):             val = os.environ.get(envar)
 --- modulename: _collections_abc, funcname: get
_collections_abc.py(659):         try:
_collections_abc.py(660):             return self[key]
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
_collections_abc.py(661):         except KeyError:
_collections_abc.py(662):             return default
gettext.py(546):             if val:
gettext.py(544):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(545):             val = os.environ.get(envar)
 --- modulename: _collections_abc, funcname: get
_collections_abc.py(659):         try:
_collections_abc.py(660):             return self[key]
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
_collections_abc.py(661):         except KeyError:
_collections_abc.py(662):             return default
gettext.py(546):             if val:
gettext.py(544):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(545):             val = os.environ.get(envar)
 --- modulename: _collections_abc, funcname: get
_collections_abc.py(659):         try:
_collections_abc.py(660):             return self[key]
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
_collections_abc.py(661):         except KeyError:
_collections_abc.py(662):             return default
gettext.py(546):             if val:
gettext.py(544):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(545):             val = os.environ.get(envar)
 --- modulename: _collections_abc, funcname: get
_collections_abc.py(659):         try:
_collections_abc.py(660):             return self[key]
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(676):         return self.decodevalue(value)
 --- modulename: os, funcname: decode
os.py(753):             return value.decode(encoding, 'surrogateescape')
gettext.py(546):             if val:
gettext.py(547):                 languages = val.split(':')
gettext.py(548):                 break
gettext.py(549):         if 'C' not in languages:
gettext.py(550):             languages.append('C')
gettext.py(552):     nelangs = []
gettext.py(553):     for lang in languages:
gettext.py(554):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(213):     loc = locale.normalize(loc)
 --- modulename: locale, funcname: normalize
locale.py(401):     code = localename.lower()
locale.py(402):     if ':' in code:
locale.py(405):     if '@' in code:
locale.py(408):         modifier = ''
locale.py(409):     if '.' in code:
locale.py(410):         langname, encoding = code.split('.')[:2]
locale.py(416):     lang_enc = langname
locale.py(417):     if encoding:
locale.py(418):         norm_encoding = encoding.replace('-', '')
locale.py(419):         norm_encoding = norm_encoding.replace('_', '')
locale.py(420):         lang_enc += '.' + norm_encoding
locale.py(421):     lookup_name = lang_enc
locale.py(422):     if modifier:
locale.py(424):     code = locale_alias.get(lookup_name, None)
locale.py(425):     if code is not None:
locale.py(429):     if modifier:
locale.py(440):     if encoding:
locale.py(442):         lookup_name = langname
locale.py(443):         if modifier:
locale.py(445):         code = locale_alias.get(lookup_name, None)
locale.py(446):         if code is not None:
locale.py(448):             if '@' not in code:
locale.py(449):                 return _replace_encoding(code, encoding)
 --- modulename: locale, funcname: _replace_encoding
locale.py(351):     if '.' in code:
locale.py(352):         langname = code[:code.index('.')]
locale.py(356):     norm_encoding = encodings.normalize_encoding(encoding)
 --- modulename: __init__, funcname: normalize_encoding
__init__.py(55):     if isinstance(encoding, bytes):
__init__.py(58):     chars = []
__init__.py(59):     punct = False
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(62):             if punct and chars:
__init__.py(64):             chars.append(c)
__init__.py(65):             punct = False
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(62):             if punct and chars:
__init__.py(64):             chars.append(c)
__init__.py(65):             punct = False
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(62):             if punct and chars:
__init__.py(64):             chars.append(c)
__init__.py(65):             punct = False
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(67):             punct = True
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(62):             if punct and chars:
__init__.py(63):                 chars.append('_')
__init__.py(64):             chars.append(c)
__init__.py(65):             punct = False
__init__.py(60):     for c in encoding:
__init__.py(68):     return ''.join(chars)
locale.py(358):     norm_encoding = encodings.aliases.aliases.get(norm_encoding.lower(),
locale.py(359):                                                   norm_encoding)
locale.py(358):     norm_encoding = encodings.aliases.aliases.get(norm_encoding.lower(),
locale.py(361):     encoding = norm_encoding
locale.py(362):     norm_encoding = norm_encoding.lower()
locale.py(363):     if norm_encoding in locale_encoding_alias:
locale.py(364):         encoding = locale_encoding_alias[norm_encoding]
locale.py(371):     return langname + '.' + encoding
gettext.py(214):     COMPONENT_CODESET   = 1 << 0
gettext.py(215):     COMPONENT_TERRITORY = 1 << 1
gettext.py(216):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(218):     mask = 0
gettext.py(219):     pos = loc.find('@')
gettext.py(220):     if pos >= 0:
gettext.py(225):         modifier = ''
gettext.py(226):     pos = loc.find('.')
gettext.py(227):     if pos >= 0:
gettext.py(228):         codeset = loc[pos:]
gettext.py(229):         loc = loc[:pos]
gettext.py(230):         mask |= COMPONENT_CODESET
gettext.py(233):     pos = loc.find('_')
gettext.py(234):     if pos >= 0:
gettext.py(235):         territory = loc[pos:]
gettext.py(236):         loc = loc[:pos]
gettext.py(237):         mask |= COMPONENT_TERRITORY
gettext.py(240):     language = loc
gettext.py(241):     ret = []
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(249):     ret.reverse()
gettext.py(250):     return ret
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(553):     for lang in languages:
gettext.py(554):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(213):     loc = locale.normalize(loc)
 --- modulename: locale, funcname: normalize
locale.py(401):     code = localename.lower()
locale.py(402):     if ':' in code:
locale.py(405):     if '@' in code:
locale.py(408):         modifier = ''
locale.py(409):     if '.' in code:
locale.py(412):         langname = code
locale.py(413):         encoding = ''
locale.py(416):     lang_enc = langname
locale.py(417):     if encoding:
locale.py(421):     lookup_name = lang_enc
locale.py(422):     if modifier:
locale.py(424):     code = locale_alias.get(lookup_name, None)
locale.py(425):     if code is not None:
locale.py(426):         return code
gettext.py(214):     COMPONENT_CODESET   = 1 << 0
gettext.py(215):     COMPONENT_TERRITORY = 1 << 1
gettext.py(216):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(218):     mask = 0
gettext.py(219):     pos = loc.find('@')
gettext.py(220):     if pos >= 0:
gettext.py(225):         modifier = ''
gettext.py(226):     pos = loc.find('.')
gettext.py(227):     if pos >= 0:
gettext.py(232):         codeset = ''
gettext.py(233):     pos = loc.find('_')
gettext.py(234):     if pos >= 0:
gettext.py(239):         territory = ''
gettext.py(240):     language = loc
gettext.py(241):     ret = []
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(249):     ret.reverse()
gettext.py(250):     return ret
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(553):     for lang in languages:
gettext.py(558):     if all:
gettext.py(559):         result = []
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(565):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
gettext.py(566):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(18):     try:
genericpath.py(19):         os.stat(path)
genericpath.py(20):     except (OSError, ValueError):
genericpath.py(21):         return False
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(565):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
gettext.py(566):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(18):     try:
genericpath.py(19):         os.stat(path)
genericpath.py(20):     except (OSError, ValueError):
genericpath.py(21):         return False
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(565):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
gettext.py(566):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(18):     try:
genericpath.py(19):         os.stat(path)
genericpath.py(20):     except (OSError, ValueError):
genericpath.py(21):         return False
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(565):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
gettext.py(566):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(18):     try:
genericpath.py(19):         os.stat(path)
genericpath.py(20):     except (OSError, ValueError):
genericpath.py(21):         return False
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(564):             break
gettext.py(571):     return result
gettext.py(584):     if not mofiles:
gettext.py(585):         if fallback:
gettext.py(587):         from errno import ENOENT
gettext.py(588):         raise FileNotFoundError(ENOENT,
gettext.py(589):                                 'No translation file found for domain', domain)
gettext.py(588):         raise FileNotFoundError(ENOENT,
gettext.py(663):     except OSError:
gettext.py(664):         return message
 --- modulename: argparse, funcname: add_argument_group
argparse.py(1389):         group = _ArgumentGroup(self, *args, **kwargs)
 --- modulename: argparse, funcname: __init__
argparse.py(1569):         update = kwargs.setdefault
argparse.py(1570):         update('conflict_handler', container.conflict_handler)
argparse.py(1571):         update('prefix_chars', container.prefix_chars)
argparse.py(1572):         update('argument_default', container.argument_default)
argparse.py(1573):         super_init = super(_ArgumentGroup, self).__init__
argparse.py(1574):         super_init(description=description, **kwargs)
 --- modulename: argparse, funcname: __init__
argparse.py(1260):         super(_ActionsContainer, self).__init__()
argparse.py(1262):         self.description = description
argparse.py(1263):         self.argument_default = argument_default
argparse.py(1264):         self.prefix_chars = prefix_chars
argparse.py(1265):         self.conflict_handler = conflict_handler
argparse.py(1268):         self._registries = {}
argparse.py(1271):         self.register('action', None, _StoreAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1272):         self.register('action', 'store', _StoreAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1273):         self.register('action', 'store_const', _StoreConstAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1274):         self.register('action', 'store_true', _StoreTrueAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1275):         self.register('action', 'store_false', _StoreFalseAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1276):         self.register('action', 'append', _AppendAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1277):         self.register('action', 'append_const', _AppendConstAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1278):         self.register('action', 'count', _CountAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1279):         self.register('action', 'help', _HelpAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1280):         self.register('action', 'version', _VersionAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1281):         self.register('action', 'parsers', _SubParsersAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1282):         self.register('action', 'extend', _ExtendAction)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1285):         self._get_handler()
 --- modulename: argparse, funcname: _get_handler
argparse.py(1520):         handler_func_name = '_handle_conflict_%s' % self.conflict_handler
argparse.py(1521):         try:
argparse.py(1522):             return getattr(self, handler_func_name)
argparse.py(1288):         self._actions = []
argparse.py(1289):         self._option_string_actions = {}
argparse.py(1292):         self._action_groups = []
argparse.py(1293):         self._mutually_exclusive_groups = []
argparse.py(1296):         self._defaults = {}
argparse.py(1299):         self._negative_number_matcher = _re.compile(r'^-\d+$|^-\d*\.\d+$')
 --- modulename: re, funcname: compile
re.py(252):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
argparse.py(1303):         self._has_negative_number_optionals = []
argparse.py(1577):         self.title = title
argparse.py(1578):         self._group_actions = []
argparse.py(1581):         self._registries = container._registries
argparse.py(1582):         self._actions = container._actions
argparse.py(1583):         self._option_string_actions = container._option_string_actions
argparse.py(1584):         self._defaults = container._defaults
argparse.py(1586):             container._has_negative_number_optionals
argparse.py(1585):         self._has_negative_number_optionals = \
argparse.py(1587):         self._mutually_exclusive_groups = container._mutually_exclusive_groups
argparse.py(1390):         self._action_groups.append(group)
argparse.py(1391):         return group
argparse.py(1673):         self._subparsers = None
argparse.py(1676):         def identity(string):
argparse.py(1678):         self.register('type', None, identity)
 --- modulename: argparse, funcname: register
argparse.py(1309):         registry = self._registries.setdefault(registry_name, {})
argparse.py(1310):         registry[value] = object
argparse.py(1682):         default_prefix = '-' if '-' in prefix_chars else prefix_chars[0]
argparse.py(1683):         if self.add_help:
argparse.py(1684):             self.add_argument(
argparse.py(1685):                 default_prefix+'h', default_prefix*2+'help',
argparse.py(1686):                 action='help', default=SUPPRESS,
argparse.py(1687):                 help=_('show this help message and exit'))
 --- modulename: gettext, funcname: gettext
gettext.py(736):     return dgettext(_current_domain, message)
 --- modulename: gettext, funcname: dgettext
gettext.py(661):     try:
gettext.py(662):         t = translation(domain, _localedirs.get(domain, None))
 --- modulename: gettext, funcname: translation
gettext.py(581):     if class_ is None:
gettext.py(582):         class_ = GNUTranslations
gettext.py(583):     mofiles = find(domain, localedir, languages, all=True)
 --- modulename: gettext, funcname: find
gettext.py(540):     if localedir is None:
gettext.py(541):         localedir = _default_localedir
gettext.py(542):     if languages is None:
gettext.py(543):         languages = []
gettext.py(544):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(545):             val = os.environ.get(envar)
 --- modulename: _collections_abc, funcname: get
_collections_abc.py(659):         try:
_collections_abc.py(660):             return self[key]
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
_collections_abc.py(661):         except KeyError:
_collections_abc.py(662):             return default
gettext.py(546):             if val:
gettext.py(544):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(545):             val = os.environ.get(envar)
 --- modulename: _collections_abc, funcname: get
_collections_abc.py(659):         try:
_collections_abc.py(660):             return self[key]
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
_collections_abc.py(661):         except KeyError:
_collections_abc.py(662):             return default
gettext.py(546):             if val:
gettext.py(544):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(545):             val = os.environ.get(envar)
 --- modulename: _collections_abc, funcname: get
_collections_abc.py(659):         try:
_collections_abc.py(660):             return self[key]
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
_collections_abc.py(661):         except KeyError:
_collections_abc.py(662):             return default
gettext.py(546):             if val:
gettext.py(544):         for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
gettext.py(545):             val = os.environ.get(envar)
 --- modulename: _collections_abc, funcname: get
_collections_abc.py(659):         try:
_collections_abc.py(660):             return self[key]
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(676):         return self.decodevalue(value)
 --- modulename: os, funcname: decode
os.py(753):             return value.decode(encoding, 'surrogateescape')
gettext.py(546):             if val:
gettext.py(547):                 languages = val.split(':')
gettext.py(548):                 break
gettext.py(549):         if 'C' not in languages:
gettext.py(550):             languages.append('C')
gettext.py(552):     nelangs = []
gettext.py(553):     for lang in languages:
gettext.py(554):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(213):     loc = locale.normalize(loc)
 --- modulename: locale, funcname: normalize
locale.py(401):     code = localename.lower()
locale.py(402):     if ':' in code:
locale.py(405):     if '@' in code:
locale.py(408):         modifier = ''
locale.py(409):     if '.' in code:
locale.py(410):         langname, encoding = code.split('.')[:2]
locale.py(416):     lang_enc = langname
locale.py(417):     if encoding:
locale.py(418):         norm_encoding = encoding.replace('-', '')
locale.py(419):         norm_encoding = norm_encoding.replace('_', '')
locale.py(420):         lang_enc += '.' + norm_encoding
locale.py(421):     lookup_name = lang_enc
locale.py(422):     if modifier:
locale.py(424):     code = locale_alias.get(lookup_name, None)
locale.py(425):     if code is not None:
locale.py(429):     if modifier:
locale.py(440):     if encoding:
locale.py(442):         lookup_name = langname
locale.py(443):         if modifier:
locale.py(445):         code = locale_alias.get(lookup_name, None)
locale.py(446):         if code is not None:
locale.py(448):             if '@' not in code:
locale.py(449):                 return _replace_encoding(code, encoding)
 --- modulename: locale, funcname: _replace_encoding
locale.py(351):     if '.' in code:
locale.py(352):         langname = code[:code.index('.')]
locale.py(356):     norm_encoding = encodings.normalize_encoding(encoding)
 --- modulename: __init__, funcname: normalize_encoding
__init__.py(55):     if isinstance(encoding, bytes):
__init__.py(58):     chars = []
__init__.py(59):     punct = False
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(62):             if punct and chars:
__init__.py(64):             chars.append(c)
__init__.py(65):             punct = False
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(62):             if punct and chars:
__init__.py(64):             chars.append(c)
__init__.py(65):             punct = False
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(62):             if punct and chars:
__init__.py(64):             chars.append(c)
__init__.py(65):             punct = False
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(67):             punct = True
__init__.py(60):     for c in encoding:
__init__.py(61):         if c.isalnum() or c == '.':
__init__.py(62):             if punct and chars:
__init__.py(63):                 chars.append('_')
__init__.py(64):             chars.append(c)
__init__.py(65):             punct = False
__init__.py(60):     for c in encoding:
__init__.py(68):     return ''.join(chars)
locale.py(358):     norm_encoding = encodings.aliases.aliases.get(norm_encoding.lower(),
locale.py(359):                                                   norm_encoding)
locale.py(358):     norm_encoding = encodings.aliases.aliases.get(norm_encoding.lower(),
locale.py(361):     encoding = norm_encoding
locale.py(362):     norm_encoding = norm_encoding.lower()
locale.py(363):     if norm_encoding in locale_encoding_alias:
locale.py(364):         encoding = locale_encoding_alias[norm_encoding]
locale.py(371):     return langname + '.' + encoding
gettext.py(214):     COMPONENT_CODESET   = 1 << 0
gettext.py(215):     COMPONENT_TERRITORY = 1 << 1
gettext.py(216):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(218):     mask = 0
gettext.py(219):     pos = loc.find('@')
gettext.py(220):     if pos >= 0:
gettext.py(225):         modifier = ''
gettext.py(226):     pos = loc.find('.')
gettext.py(227):     if pos >= 0:
gettext.py(228):         codeset = loc[pos:]
gettext.py(229):         loc = loc[:pos]
gettext.py(230):         mask |= COMPONENT_CODESET
gettext.py(233):     pos = loc.find('_')
gettext.py(234):     if pos >= 0:
gettext.py(235):         territory = loc[pos:]
gettext.py(236):         loc = loc[:pos]
gettext.py(237):         mask |= COMPONENT_TERRITORY
gettext.py(240):     language = loc
gettext.py(241):     ret = []
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(249):     ret.reverse()
gettext.py(250):     return ret
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(553):     for lang in languages:
gettext.py(554):         for nelang in _expand_lang(lang):
 --- modulename: gettext, funcname: _expand_lang
gettext.py(213):     loc = locale.normalize(loc)
 --- modulename: locale, funcname: normalize
locale.py(401):     code = localename.lower()
locale.py(402):     if ':' in code:
locale.py(405):     if '@' in code:
locale.py(408):         modifier = ''
locale.py(409):     if '.' in code:
locale.py(412):         langname = code
locale.py(413):         encoding = ''
locale.py(416):     lang_enc = langname
locale.py(417):     if encoding:
locale.py(421):     lookup_name = lang_enc
locale.py(422):     if modifier:
locale.py(424):     code = locale_alias.get(lookup_name, None)
locale.py(425):     if code is not None:
locale.py(426):         return code
gettext.py(214):     COMPONENT_CODESET   = 1 << 0
gettext.py(215):     COMPONENT_TERRITORY = 1 << 1
gettext.py(216):     COMPONENT_MODIFIER  = 1 << 2
gettext.py(218):     mask = 0
gettext.py(219):     pos = loc.find('@')
gettext.py(220):     if pos >= 0:
gettext.py(225):         modifier = ''
gettext.py(226):     pos = loc.find('.')
gettext.py(227):     if pos >= 0:
gettext.py(232):         codeset = ''
gettext.py(233):     pos = loc.find('_')
gettext.py(234):     if pos >= 0:
gettext.py(239):         territory = ''
gettext.py(240):     language = loc
gettext.py(241):     ret = []
gettext.py(242):     for i in range(mask+1):
gettext.py(243):         if not (i & ~mask):  # if all components for this combo exist ...
gettext.py(244):             val = language
gettext.py(245):             if i & COMPONENT_TERRITORY: val += territory
gettext.py(246):             if i & COMPONENT_CODESET:   val += codeset
gettext.py(247):             if i & COMPONENT_MODIFIER:  val += modifier
gettext.py(248):             ret.append(val)
gettext.py(242):     for i in range(mask+1):
gettext.py(249):     ret.reverse()
gettext.py(250):     return ret
gettext.py(555):             if nelang not in nelangs:
gettext.py(556):                 nelangs.append(nelang)
gettext.py(554):         for nelang in _expand_lang(lang):
gettext.py(553):     for lang in languages:
gettext.py(558):     if all:
gettext.py(559):         result = []
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(565):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
gettext.py(566):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(18):     try:
genericpath.py(19):         os.stat(path)
genericpath.py(20):     except (OSError, ValueError):
genericpath.py(21):         return False
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(565):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
gettext.py(566):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(18):     try:
genericpath.py(19):         os.stat(path)
genericpath.py(20):     except (OSError, ValueError):
genericpath.py(21):         return False
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(565):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
gettext.py(566):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(18):     try:
genericpath.py(19):         os.stat(path)
genericpath.py(20):     except (OSError, ValueError):
genericpath.py(21):         return False
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(565):         mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
gettext.py(566):         if os.path.exists(mofile):
 --- modulename: genericpath, funcname: exists
genericpath.py(18):     try:
genericpath.py(19):         os.stat(path)
genericpath.py(20):     except (OSError, ValueError):
genericpath.py(21):         return False
gettext.py(562):     for lang in nelangs:
gettext.py(563):         if lang == 'C':
gettext.py(564):             break
gettext.py(571):     return result
gettext.py(584):     if not mofiles:
gettext.py(585):         if fallback:
gettext.py(587):         from errno import ENOENT
gettext.py(588):         raise FileNotFoundError(ENOENT,
gettext.py(589):                                 'No translation file found for domain', domain)
gettext.py(588):         raise FileNotFoundError(ENOENT,
gettext.py(663):     except OSError:
gettext.py(664):         return message
argparse.py(1684):             self.add_argument(
 --- modulename: argparse, funcname: add_argument
argparse.py(1346):         chars = self.prefix_chars
argparse.py(1347):         if not args or len(args) == 1 and args[0][0] not in chars:
argparse.py(1354):             kwargs = self._get_optional_kwargs(*args, **kwargs)
 --- modulename: argparse, funcname: _get_optional_kwargs
argparse.py(1480):         option_strings = []
argparse.py(1481):         long_option_strings = []
argparse.py(1482):         for option_string in args:
argparse.py(1484):             if not option_string[0] in self.prefix_chars:
argparse.py(1492):             option_strings.append(option_string)
argparse.py(1493):             if option_string[0] in self.prefix_chars:
argparse.py(1494):                 if len(option_string) > 1:
argparse.py(1495):                     if option_string[1] in self.prefix_chars:
argparse.py(1482):         for option_string in args:
argparse.py(1484):             if not option_string[0] in self.prefix_chars:
argparse.py(1492):             option_strings.append(option_string)
argparse.py(1493):             if option_string[0] in self.prefix_chars:
argparse.py(1494):                 if len(option_string) > 1:
argparse.py(1495):                     if option_string[1] in self.prefix_chars:
argparse.py(1496):                         long_option_strings.append(option_string)
argparse.py(1482):         for option_string in args:
argparse.py(1499):         dest = kwargs.pop('dest', None)
argparse.py(1500):         if dest is None:
argparse.py(1501):             if long_option_strings:
argparse.py(1502):                 dest_option_string = long_option_strings[0]
argparse.py(1505):             dest = dest_option_string.lstrip(self.prefix_chars)
argparse.py(1506):             if not dest:
argparse.py(1509):             dest = dest.replace('-', '_')
argparse.py(1512):         return dict(kwargs, dest=dest, option_strings=option_strings)
argparse.py(1357):         if 'default' not in kwargs:
argparse.py(1365):         action_class = self._pop_action_class(kwargs)
 --- modulename: argparse, funcname: _pop_action_class
argparse.py(1515):         action = kwargs.pop('action', default)
argparse.py(1516):         return self._registry_get('action', action, action)
 --- modulename: argparse, funcname: _registry_get
argparse.py(1313):         return self._registries[registry_name].get(value, default)
argparse.py(1366):         if not callable(action_class):
argparse.py(1368):         action = action_class(**kwargs)
 --- modulename: argparse, funcname: __init__
argparse.py(1036):         super(_HelpAction, self).__init__(
argparse.py(1037):             option_strings=option_strings,
argparse.py(1038):             dest=dest,
argparse.py(1039):             default=default,
argparse.py(1040):             nargs=0,
argparse.py(1041):             help=help)
argparse.py(1036):         super(_HelpAction, self).__init__(
 --- modulename: argparse, funcname: __init__
argparse.py(820):         self.option_strings = option_strings
argparse.py(821):         self.dest = dest
argparse.py(822):         self.nargs = nargs
argparse.py(823):         self.const = const
argparse.py(824):         self.default = default
argparse.py(825):         self.type = type
argparse.py(826):         self.choices = choices
argparse.py(827):         self.required = required
argparse.py(828):         self.help = help
argparse.py(829):         self.metavar = metavar
argparse.py(1371):         type_func = self._registry_get('type', action.type, action.type)
 --- modulename: argparse, funcname: _registry_get
argparse.py(1313):         return self._registries[registry_name].get(value, default)
argparse.py(1372):         if not callable(type_func):
argparse.py(1375):         if type_func is FileType:
argparse.py(1380):         if hasattr(self, "_get_formatter"):
argparse.py(1381):             try:
argparse.py(1382):                 self._get_formatter()._format_args(action, None)
 --- modulename: argparse, funcname: _get_formatter
argparse.py(2481):         return self.formatter_class(prog=self.prog)
 --- modulename: argparse, funcname: __init__
argparse.py(168):         if width is None:
argparse.py(169):             width = _shutil.get_terminal_size().columns
 --- modulename: shutil, funcname: get_terminal_size
shutil.py(1332):     try:
shutil.py(1333):         columns = int(os.environ['COLUMNS'])
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
shutil.py(1334):     except (KeyError, ValueError):
shutil.py(1335):         columns = 0
shutil.py(1337):     try:
shutil.py(1338):         lines = int(os.environ['LINES'])
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
shutil.py(1339):     except (KeyError, ValueError):
shutil.py(1340):         lines = 0
shutil.py(1343):     if columns <= 0 or lines <= 0:
shutil.py(1344):         try:
shutil.py(1345):             size = os.get_terminal_size(sys.__stdout__.fileno())
shutil.py(1346):         except (AttributeError, ValueError, OSError):
shutil.py(1349):             size = os.terminal_size(fallback)
shutil.py(1350):         if columns <= 0:
shutil.py(1351):             columns = size.columns
shutil.py(1352):         if lines <= 0:
shutil.py(1353):             lines = size.lines
shutil.py(1355):     return os.terminal_size((columns, lines))
argparse.py(170):             width -= 2
argparse.py(172):         self._prog = prog
argparse.py(173):         self._indent_increment = indent_increment
argparse.py(174):         self._max_help_position = min(max_help_position,
argparse.py(175):                                       max(width - 20, indent_increment * 2))
argparse.py(174):         self._max_help_position = min(max_help_position,
argparse.py(176):         self._width = width
argparse.py(178):         self._current_indent = 0
argparse.py(179):         self._level = 0
argparse.py(180):         self._action_max_length = 0
argparse.py(182):         self._root_section = self._Section(self, None)
 --- modulename: argparse, funcname: __init__
argparse.py(203):             self.formatter = formatter
argparse.py(204):             self.parent = parent
argparse.py(205):             self.heading = heading
argparse.py(206):             self.items = []
argparse.py(183):         self._current_section = self._root_section
argparse.py(185):         self._whitespace_matcher = _re.compile(r'\s+', _re.ASCII)
 --- modulename: re, funcname: compile
re.py(252):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(292):         flags = flags.value
 --- modulename: types, funcname: __get__
types.py(172):         if instance is None:
types.py(176):         elif self.fget is None:
types.py(178):         return self.fget(instance)
 --- modulename: enum, funcname: value
enum.py(756):         return self._value_
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
argparse.py(186):         self._long_break_matcher = _re.compile(r'\n\n\n+')
 --- modulename: re, funcname: compile
re.py(252):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
 --- modulename: argparse, funcname: _format_args
argparse.py(587):         get_metavar = self._metavar_formatter(action, default_metavar)
 --- modulename: argparse, funcname: _metavar_formatter
argparse.py(571):         if action.metavar is not None:
argparse.py(573):         elif action.choices is not None:
argparse.py(577):             result = default_metavar
argparse.py(579):         def format(tuple_size):
argparse.py(584):         return format
argparse.py(588):         if action.nargs is None:
argparse.py(590):         elif action.nargs == OPTIONAL:
argparse.py(592):         elif action.nargs == ZERO_OR_MORE:
argparse.py(594):         elif action.nargs == ONE_OR_MORE:
argparse.py(596):         elif action.nargs == REMAINDER:
argparse.py(598):         elif action.nargs == PARSER:
argparse.py(600):         elif action.nargs == SUPPRESS:
argparse.py(603):             try:
argparse.py(604):                 formats = ['%s' for _ in range(action.nargs)]
 --- modulename: argparse, funcname: <listcomp>
argparse.py(604):                 formats = ['%s' for _ in range(action.nargs)]
argparse.py(607):             result = ' '.join(formats) % get_metavar(action.nargs)
 --- modulename: argparse, funcname: format
argparse.py(580):             if isinstance(result, tuple):
argparse.py(583):                 return (result, ) * tuple_size
argparse.py(608):         return result
argparse.py(1386):         return self._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1748):         if action.option_strings:
argparse.py(1749):             self._optionals._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1590):         action = super(_ArgumentGroup, self)._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1400):         self._check_conflict(action)
 --- modulename: argparse, funcname: _check_conflict
argparse.py(1530):         confl_optionals = []
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1532):             if option_string in self._option_string_actions:
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1532):             if option_string in self._option_string_actions:
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1537):         if confl_optionals:
argparse.py(1403):         self._actions.append(action)
argparse.py(1404):         action.container = self
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1408):             self._option_string_actions[option_string] = action
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1408):             self._option_string_actions[option_string] = action
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1412):             if self._negative_number_matcher.match(option_string):
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1412):             if self._negative_number_matcher.match(option_string):
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1417):         return action
argparse.py(1591):         self._group_actions.append(action)
argparse.py(1592):         return action
argparse.py(1752):         return action
argparse.py(1690):         for parent in parents:
__main__.py(36): parser.add_argument(
__main__.py(37):     "--src", "-i", type=Path, help="Input CSV file"
__main__.py(36): parser.add_argument(
 --- modulename: argparse, funcname: add_argument
argparse.py(1346):         chars = self.prefix_chars
argparse.py(1347):         if not args or len(args) == 1 and args[0][0] not in chars:
argparse.py(1354):             kwargs = self._get_optional_kwargs(*args, **kwargs)
 --- modulename: argparse, funcname: _get_optional_kwargs
argparse.py(1480):         option_strings = []
argparse.py(1481):         long_option_strings = []
argparse.py(1482):         for option_string in args:
argparse.py(1484):             if not option_string[0] in self.prefix_chars:
argparse.py(1492):             option_strings.append(option_string)
argparse.py(1493):             if option_string[0] in self.prefix_chars:
argparse.py(1494):                 if len(option_string) > 1:
argparse.py(1495):                     if option_string[1] in self.prefix_chars:
argparse.py(1496):                         long_option_strings.append(option_string)
argparse.py(1482):         for option_string in args:
argparse.py(1484):             if not option_string[0] in self.prefix_chars:
argparse.py(1492):             option_strings.append(option_string)
argparse.py(1493):             if option_string[0] in self.prefix_chars:
argparse.py(1494):                 if len(option_string) > 1:
argparse.py(1495):                     if option_string[1] in self.prefix_chars:
argparse.py(1482):         for option_string in args:
argparse.py(1499):         dest = kwargs.pop('dest', None)
argparse.py(1500):         if dest is None:
argparse.py(1501):             if long_option_strings:
argparse.py(1502):                 dest_option_string = long_option_strings[0]
argparse.py(1505):             dest = dest_option_string.lstrip(self.prefix_chars)
argparse.py(1506):             if not dest:
argparse.py(1509):             dest = dest.replace('-', '_')
argparse.py(1512):         return dict(kwargs, dest=dest, option_strings=option_strings)
argparse.py(1357):         if 'default' not in kwargs:
argparse.py(1358):             dest = kwargs['dest']
argparse.py(1359):             if dest in self._defaults:
argparse.py(1361):             elif self.argument_default is not None:
argparse.py(1365):         action_class = self._pop_action_class(kwargs)
 --- modulename: argparse, funcname: _pop_action_class
argparse.py(1515):         action = kwargs.pop('action', default)
argparse.py(1516):         return self._registry_get('action', action, action)
 --- modulename: argparse, funcname: _registry_get
argparse.py(1313):         return self._registries[registry_name].get(value, default)
argparse.py(1366):         if not callable(action_class):
argparse.py(1368):         action = action_class(**kwargs)
 --- modulename: argparse, funcname: __init__
argparse.py(862):         if nargs == 0:
argparse.py(866):         if const is not None and nargs != OPTIONAL:
argparse.py(868):         super(_StoreAction, self).__init__(
argparse.py(869):             option_strings=option_strings,
argparse.py(870):             dest=dest,
argparse.py(871):             nargs=nargs,
argparse.py(872):             const=const,
argparse.py(873):             default=default,
argparse.py(874):             type=type,
argparse.py(875):             choices=choices,
argparse.py(876):             required=required,
argparse.py(877):             help=help,
argparse.py(878):             metavar=metavar)
argparse.py(868):         super(_StoreAction, self).__init__(
 --- modulename: argparse, funcname: __init__
argparse.py(820):         self.option_strings = option_strings
argparse.py(821):         self.dest = dest
argparse.py(822):         self.nargs = nargs
argparse.py(823):         self.const = const
argparse.py(824):         self.default = default
argparse.py(825):         self.type = type
argparse.py(826):         self.choices = choices
argparse.py(827):         self.required = required
argparse.py(828):         self.help = help
argparse.py(829):         self.metavar = metavar
argparse.py(1371):         type_func = self._registry_get('type', action.type, action.type)
 --- modulename: argparse, funcname: _registry_get
argparse.py(1313):         return self._registries[registry_name].get(value, default)
argparse.py(1372):         if not callable(type_func):
argparse.py(1375):         if type_func is FileType:
argparse.py(1380):         if hasattr(self, "_get_formatter"):
argparse.py(1381):             try:
argparse.py(1382):                 self._get_formatter()._format_args(action, None)
 --- modulename: argparse, funcname: _get_formatter
argparse.py(2481):         return self.formatter_class(prog=self.prog)
 --- modulename: argparse, funcname: __init__
argparse.py(168):         if width is None:
argparse.py(169):             width = _shutil.get_terminal_size().columns
 --- modulename: shutil, funcname: get_terminal_size
shutil.py(1332):     try:
shutil.py(1333):         columns = int(os.environ['COLUMNS'])
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
shutil.py(1334):     except (KeyError, ValueError):
shutil.py(1335):         columns = 0
shutil.py(1337):     try:
shutil.py(1338):         lines = int(os.environ['LINES'])
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
shutil.py(1339):     except (KeyError, ValueError):
shutil.py(1340):         lines = 0
shutil.py(1343):     if columns <= 0 or lines <= 0:
shutil.py(1344):         try:
shutil.py(1345):             size = os.get_terminal_size(sys.__stdout__.fileno())
shutil.py(1346):         except (AttributeError, ValueError, OSError):
shutil.py(1349):             size = os.terminal_size(fallback)
shutil.py(1350):         if columns <= 0:
shutil.py(1351):             columns = size.columns
shutil.py(1352):         if lines <= 0:
shutil.py(1353):             lines = size.lines
shutil.py(1355):     return os.terminal_size((columns, lines))
argparse.py(170):             width -= 2
argparse.py(172):         self._prog = prog
argparse.py(173):         self._indent_increment = indent_increment
argparse.py(174):         self._max_help_position = min(max_help_position,
argparse.py(175):                                       max(width - 20, indent_increment * 2))
argparse.py(174):         self._max_help_position = min(max_help_position,
argparse.py(176):         self._width = width
argparse.py(178):         self._current_indent = 0
argparse.py(179):         self._level = 0
argparse.py(180):         self._action_max_length = 0
argparse.py(182):         self._root_section = self._Section(self, None)
 --- modulename: argparse, funcname: __init__
argparse.py(203):             self.formatter = formatter
argparse.py(204):             self.parent = parent
argparse.py(205):             self.heading = heading
argparse.py(206):             self.items = []
argparse.py(183):         self._current_section = self._root_section
argparse.py(185):         self._whitespace_matcher = _re.compile(r'\s+', _re.ASCII)
 --- modulename: re, funcname: compile
re.py(252):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(292):         flags = flags.value
 --- modulename: types, funcname: __get__
types.py(172):         if instance is None:
types.py(176):         elif self.fget is None:
types.py(178):         return self.fget(instance)
 --- modulename: enum, funcname: value
enum.py(756):         return self._value_
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
argparse.py(186):         self._long_break_matcher = _re.compile(r'\n\n\n+')
 --- modulename: re, funcname: compile
re.py(252):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
 --- modulename: argparse, funcname: _format_args
argparse.py(587):         get_metavar = self._metavar_formatter(action, default_metavar)
 --- modulename: argparse, funcname: _metavar_formatter
argparse.py(571):         if action.metavar is not None:
argparse.py(573):         elif action.choices is not None:
argparse.py(577):             result = default_metavar
argparse.py(579):         def format(tuple_size):
argparse.py(584):         return format
argparse.py(588):         if action.nargs is None:
argparse.py(589):             result = '%s' % get_metavar(1)
 --- modulename: argparse, funcname: format
argparse.py(580):             if isinstance(result, tuple):
argparse.py(583):                 return (result, ) * tuple_size
argparse.py(608):         return result
argparse.py(1386):         return self._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1748):         if action.option_strings:
argparse.py(1749):             self._optionals._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1590):         action = super(_ArgumentGroup, self)._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1400):         self._check_conflict(action)
 --- modulename: argparse, funcname: _check_conflict
argparse.py(1530):         confl_optionals = []
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1532):             if option_string in self._option_string_actions:
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1532):             if option_string in self._option_string_actions:
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1537):         if confl_optionals:
argparse.py(1403):         self._actions.append(action)
argparse.py(1404):         action.container = self
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1408):             self._option_string_actions[option_string] = action
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1408):             self._option_string_actions[option_string] = action
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1412):             if self._negative_number_matcher.match(option_string):
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1412):             if self._negative_number_matcher.match(option_string):
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1417):         return action
argparse.py(1591):         self._group_actions.append(action)
argparse.py(1592):         return action
argparse.py(1752):         return action
__main__.py(39): parser.add_argument(
__main__.py(40):     "--dst_dir", "-o", type=Path, help="Output directory"
__main__.py(39): parser.add_argument(
 --- modulename: argparse, funcname: add_argument
argparse.py(1346):         chars = self.prefix_chars
argparse.py(1347):         if not args or len(args) == 1 and args[0][0] not in chars:
argparse.py(1354):             kwargs = self._get_optional_kwargs(*args, **kwargs)
 --- modulename: argparse, funcname: _get_optional_kwargs
argparse.py(1480):         option_strings = []
argparse.py(1481):         long_option_strings = []
argparse.py(1482):         for option_string in args:
argparse.py(1484):             if not option_string[0] in self.prefix_chars:
argparse.py(1492):             option_strings.append(option_string)
argparse.py(1493):             if option_string[0] in self.prefix_chars:
argparse.py(1494):                 if len(option_string) > 1:
argparse.py(1495):                     if option_string[1] in self.prefix_chars:
argparse.py(1496):                         long_option_strings.append(option_string)
argparse.py(1482):         for option_string in args:
argparse.py(1484):             if not option_string[0] in self.prefix_chars:
argparse.py(1492):             option_strings.append(option_string)
argparse.py(1493):             if option_string[0] in self.prefix_chars:
argparse.py(1494):                 if len(option_string) > 1:
argparse.py(1495):                     if option_string[1] in self.prefix_chars:
argparse.py(1482):         for option_string in args:
argparse.py(1499):         dest = kwargs.pop('dest', None)
argparse.py(1500):         if dest is None:
argparse.py(1501):             if long_option_strings:
argparse.py(1502):                 dest_option_string = long_option_strings[0]
argparse.py(1505):             dest = dest_option_string.lstrip(self.prefix_chars)
argparse.py(1506):             if not dest:
argparse.py(1509):             dest = dest.replace('-', '_')
argparse.py(1512):         return dict(kwargs, dest=dest, option_strings=option_strings)
argparse.py(1357):         if 'default' not in kwargs:
argparse.py(1358):             dest = kwargs['dest']
argparse.py(1359):             if dest in self._defaults:
argparse.py(1361):             elif self.argument_default is not None:
argparse.py(1365):         action_class = self._pop_action_class(kwargs)
 --- modulename: argparse, funcname: _pop_action_class
argparse.py(1515):         action = kwargs.pop('action', default)
argparse.py(1516):         return self._registry_get('action', action, action)
 --- modulename: argparse, funcname: _registry_get
argparse.py(1313):         return self._registries[registry_name].get(value, default)
argparse.py(1366):         if not callable(action_class):
argparse.py(1368):         action = action_class(**kwargs)
 --- modulename: argparse, funcname: __init__
argparse.py(862):         if nargs == 0:
argparse.py(866):         if const is not None and nargs != OPTIONAL:
argparse.py(868):         super(_StoreAction, self).__init__(
argparse.py(869):             option_strings=option_strings,
argparse.py(870):             dest=dest,
argparse.py(871):             nargs=nargs,
argparse.py(872):             const=const,
argparse.py(873):             default=default,
argparse.py(874):             type=type,
argparse.py(875):             choices=choices,
argparse.py(876):             required=required,
argparse.py(877):             help=help,
argparse.py(878):             metavar=metavar)
argparse.py(868):         super(_StoreAction, self).__init__(
 --- modulename: argparse, funcname: __init__
argparse.py(820):         self.option_strings = option_strings
argparse.py(821):         self.dest = dest
argparse.py(822):         self.nargs = nargs
argparse.py(823):         self.const = const
argparse.py(824):         self.default = default
argparse.py(825):         self.type = type
argparse.py(826):         self.choices = choices
argparse.py(827):         self.required = required
argparse.py(828):         self.help = help
argparse.py(829):         self.metavar = metavar
argparse.py(1371):         type_func = self._registry_get('type', action.type, action.type)
 --- modulename: argparse, funcname: _registry_get
argparse.py(1313):         return self._registries[registry_name].get(value, default)
argparse.py(1372):         if not callable(type_func):
argparse.py(1375):         if type_func is FileType:
argparse.py(1380):         if hasattr(self, "_get_formatter"):
argparse.py(1381):             try:
argparse.py(1382):                 self._get_formatter()._format_args(action, None)
 --- modulename: argparse, funcname: _get_formatter
argparse.py(2481):         return self.formatter_class(prog=self.prog)
 --- modulename: argparse, funcname: __init__
argparse.py(168):         if width is None:
argparse.py(169):             width = _shutil.get_terminal_size().columns
 --- modulename: shutil, funcname: get_terminal_size
shutil.py(1332):     try:
shutil.py(1333):         columns = int(os.environ['COLUMNS'])
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
shutil.py(1334):     except (KeyError, ValueError):
shutil.py(1335):         columns = 0
shutil.py(1337):     try:
shutil.py(1338):         lines = int(os.environ['LINES'])
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
shutil.py(1339):     except (KeyError, ValueError):
shutil.py(1340):         lines = 0
shutil.py(1343):     if columns <= 0 or lines <= 0:
shutil.py(1344):         try:
shutil.py(1345):             size = os.get_terminal_size(sys.__stdout__.fileno())
shutil.py(1346):         except (AttributeError, ValueError, OSError):
shutil.py(1349):             size = os.terminal_size(fallback)
shutil.py(1350):         if columns <= 0:
shutil.py(1351):             columns = size.columns
shutil.py(1352):         if lines <= 0:
shutil.py(1353):             lines = size.lines
shutil.py(1355):     return os.terminal_size((columns, lines))
argparse.py(170):             width -= 2
argparse.py(172):         self._prog = prog
argparse.py(173):         self._indent_increment = indent_increment
argparse.py(174):         self._max_help_position = min(max_help_position,
argparse.py(175):                                       max(width - 20, indent_increment * 2))
argparse.py(174):         self._max_help_position = min(max_help_position,
argparse.py(176):         self._width = width
argparse.py(178):         self._current_indent = 0
argparse.py(179):         self._level = 0
argparse.py(180):         self._action_max_length = 0
argparse.py(182):         self._root_section = self._Section(self, None)
 --- modulename: argparse, funcname: __init__
argparse.py(203):             self.formatter = formatter
argparse.py(204):             self.parent = parent
argparse.py(205):             self.heading = heading
argparse.py(206):             self.items = []
argparse.py(183):         self._current_section = self._root_section
argparse.py(185):         self._whitespace_matcher = _re.compile(r'\s+', _re.ASCII)
 --- modulename: re, funcname: compile
re.py(252):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(292):         flags = flags.value
 --- modulename: types, funcname: __get__
types.py(172):         if instance is None:
types.py(176):         elif self.fget is None:
types.py(178):         return self.fget(instance)
 --- modulename: enum, funcname: value
enum.py(756):         return self._value_
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
argparse.py(186):         self._long_break_matcher = _re.compile(r'\n\n\n+')
 --- modulename: re, funcname: compile
re.py(252):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
 --- modulename: argparse, funcname: _format_args
argparse.py(587):         get_metavar = self._metavar_formatter(action, default_metavar)
 --- modulename: argparse, funcname: _metavar_formatter
argparse.py(571):         if action.metavar is not None:
argparse.py(573):         elif action.choices is not None:
argparse.py(577):             result = default_metavar
argparse.py(579):         def format(tuple_size):
argparse.py(584):         return format
argparse.py(588):         if action.nargs is None:
argparse.py(589):             result = '%s' % get_metavar(1)
 --- modulename: argparse, funcname: format
argparse.py(580):             if isinstance(result, tuple):
argparse.py(583):                 return (result, ) * tuple_size
argparse.py(608):         return result
argparse.py(1386):         return self._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1748):         if action.option_strings:
argparse.py(1749):             self._optionals._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1590):         action = super(_ArgumentGroup, self)._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1400):         self._check_conflict(action)
 --- modulename: argparse, funcname: _check_conflict
argparse.py(1530):         confl_optionals = []
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1532):             if option_string in self._option_string_actions:
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1532):             if option_string in self._option_string_actions:
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1537):         if confl_optionals:
argparse.py(1403):         self._actions.append(action)
argparse.py(1404):         action.container = self
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1408):             self._option_string_actions[option_string] = action
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1408):             self._option_string_actions[option_string] = action
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1412):             if self._negative_number_matcher.match(option_string):
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1412):             if self._negative_number_matcher.match(option_string):
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1417):         return action
argparse.py(1591):         self._group_actions.append(action)
argparse.py(1592):         return action
argparse.py(1752):         return action
__main__.py(42): parser.add_argument(
__main__.py(43):     "--seed", "-s", default=777, type=int, help="Pseudo-random seed"
__main__.py(42): parser.add_argument(
 --- modulename: argparse, funcname: add_argument
argparse.py(1346):         chars = self.prefix_chars
argparse.py(1347):         if not args or len(args) == 1 and args[0][0] not in chars:
argparse.py(1354):             kwargs = self._get_optional_kwargs(*args, **kwargs)
 --- modulename: argparse, funcname: _get_optional_kwargs
argparse.py(1480):         option_strings = []
argparse.py(1481):         long_option_strings = []
argparse.py(1482):         for option_string in args:
argparse.py(1484):             if not option_string[0] in self.prefix_chars:
argparse.py(1492):             option_strings.append(option_string)
argparse.py(1493):             if option_string[0] in self.prefix_chars:
argparse.py(1494):                 if len(option_string) > 1:
argparse.py(1495):                     if option_string[1] in self.prefix_chars:
argparse.py(1496):                         long_option_strings.append(option_string)
argparse.py(1482):         for option_string in args:
argparse.py(1484):             if not option_string[0] in self.prefix_chars:
argparse.py(1492):             option_strings.append(option_string)
argparse.py(1493):             if option_string[0] in self.prefix_chars:
argparse.py(1494):                 if len(option_string) > 1:
argparse.py(1495):                     if option_string[1] in self.prefix_chars:
argparse.py(1482):         for option_string in args:
argparse.py(1499):         dest = kwargs.pop('dest', None)
argparse.py(1500):         if dest is None:
argparse.py(1501):             if long_option_strings:
argparse.py(1502):                 dest_option_string = long_option_strings[0]
argparse.py(1505):             dest = dest_option_string.lstrip(self.prefix_chars)
argparse.py(1506):             if not dest:
argparse.py(1509):             dest = dest.replace('-', '_')
argparse.py(1512):         return dict(kwargs, dest=dest, option_strings=option_strings)
argparse.py(1357):         if 'default' not in kwargs:
argparse.py(1365):         action_class = self._pop_action_class(kwargs)
 --- modulename: argparse, funcname: _pop_action_class
argparse.py(1515):         action = kwargs.pop('action', default)
argparse.py(1516):         return self._registry_get('action', action, action)
 --- modulename: argparse, funcname: _registry_get
argparse.py(1313):         return self._registries[registry_name].get(value, default)
argparse.py(1366):         if not callable(action_class):
argparse.py(1368):         action = action_class(**kwargs)
 --- modulename: argparse, funcname: __init__
argparse.py(862):         if nargs == 0:
argparse.py(866):         if const is not None and nargs != OPTIONAL:
argparse.py(868):         super(_StoreAction, self).__init__(
argparse.py(869):             option_strings=option_strings,
argparse.py(870):             dest=dest,
argparse.py(871):             nargs=nargs,
argparse.py(872):             const=const,
argparse.py(873):             default=default,
argparse.py(874):             type=type,
argparse.py(875):             choices=choices,
argparse.py(876):             required=required,
argparse.py(877):             help=help,
argparse.py(878):             metavar=metavar)
argparse.py(868):         super(_StoreAction, self).__init__(
 --- modulename: argparse, funcname: __init__
argparse.py(820):         self.option_strings = option_strings
argparse.py(821):         self.dest = dest
argparse.py(822):         self.nargs = nargs
argparse.py(823):         self.const = const
argparse.py(824):         self.default = default
argparse.py(825):         self.type = type
argparse.py(826):         self.choices = choices
argparse.py(827):         self.required = required
argparse.py(828):         self.help = help
argparse.py(829):         self.metavar = metavar
argparse.py(1371):         type_func = self._registry_get('type', action.type, action.type)
 --- modulename: argparse, funcname: _registry_get
argparse.py(1313):         return self._registries[registry_name].get(value, default)
argparse.py(1372):         if not callable(type_func):
argparse.py(1375):         if type_func is FileType:
argparse.py(1380):         if hasattr(self, "_get_formatter"):
argparse.py(1381):             try:
argparse.py(1382):                 self._get_formatter()._format_args(action, None)
 --- modulename: argparse, funcname: _get_formatter
argparse.py(2481):         return self.formatter_class(prog=self.prog)
 --- modulename: argparse, funcname: __init__
argparse.py(168):         if width is None:
argparse.py(169):             width = _shutil.get_terminal_size().columns
 --- modulename: shutil, funcname: get_terminal_size
shutil.py(1332):     try:
shutil.py(1333):         columns = int(os.environ['COLUMNS'])
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
shutil.py(1334):     except (KeyError, ValueError):
shutil.py(1335):         columns = 0
shutil.py(1337):     try:
shutil.py(1338):         lines = int(os.environ['LINES'])
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
shutil.py(1339):     except (KeyError, ValueError):
shutil.py(1340):         lines = 0
shutil.py(1343):     if columns <= 0 or lines <= 0:
shutil.py(1344):         try:
shutil.py(1345):             size = os.get_terminal_size(sys.__stdout__.fileno())
shutil.py(1346):         except (AttributeError, ValueError, OSError):
shutil.py(1349):             size = os.terminal_size(fallback)
shutil.py(1350):         if columns <= 0:
shutil.py(1351):             columns = size.columns
shutil.py(1352):         if lines <= 0:
shutil.py(1353):             lines = size.lines
shutil.py(1355):     return os.terminal_size((columns, lines))
argparse.py(170):             width -= 2
argparse.py(172):         self._prog = prog
argparse.py(173):         self._indent_increment = indent_increment
argparse.py(174):         self._max_help_position = min(max_help_position,
argparse.py(175):                                       max(width - 20, indent_increment * 2))
argparse.py(174):         self._max_help_position = min(max_help_position,
argparse.py(176):         self._width = width
argparse.py(178):         self._current_indent = 0
argparse.py(179):         self._level = 0
argparse.py(180):         self._action_max_length = 0
argparse.py(182):         self._root_section = self._Section(self, None)
 --- modulename: argparse, funcname: __init__
argparse.py(203):             self.formatter = formatter
argparse.py(204):             self.parent = parent
argparse.py(205):             self.heading = heading
argparse.py(206):             self.items = []
argparse.py(183):         self._current_section = self._root_section
argparse.py(185):         self._whitespace_matcher = _re.compile(r'\s+', _re.ASCII)
 --- modulename: re, funcname: compile
re.py(252):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(292):         flags = flags.value
 --- modulename: types, funcname: __get__
types.py(172):         if instance is None:
types.py(176):         elif self.fget is None:
types.py(178):         return self.fget(instance)
 --- modulename: enum, funcname: value
enum.py(756):         return self._value_
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
argparse.py(186):         self._long_break_matcher = _re.compile(r'\n\n\n+')
 --- modulename: re, funcname: compile
re.py(252):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
 --- modulename: argparse, funcname: _format_args
argparse.py(587):         get_metavar = self._metavar_formatter(action, default_metavar)
 --- modulename: argparse, funcname: _metavar_formatter
argparse.py(571):         if action.metavar is not None:
argparse.py(573):         elif action.choices is not None:
argparse.py(577):             result = default_metavar
argparse.py(579):         def format(tuple_size):
argparse.py(584):         return format
argparse.py(588):         if action.nargs is None:
argparse.py(589):             result = '%s' % get_metavar(1)
 --- modulename: argparse, funcname: format
argparse.py(580):             if isinstance(result, tuple):
argparse.py(583):                 return (result, ) * tuple_size
argparse.py(608):         return result
argparse.py(1386):         return self._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1748):         if action.option_strings:
argparse.py(1749):             self._optionals._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1590):         action = super(_ArgumentGroup, self)._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1400):         self._check_conflict(action)
 --- modulename: argparse, funcname: _check_conflict
argparse.py(1530):         confl_optionals = []
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1532):             if option_string in self._option_string_actions:
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1532):             if option_string in self._option_string_actions:
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1537):         if confl_optionals:
argparse.py(1403):         self._actions.append(action)
argparse.py(1404):         action.container = self
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1408):             self._option_string_actions[option_string] = action
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1408):             self._option_string_actions[option_string] = action
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1412):             if self._negative_number_matcher.match(option_string):
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1412):             if self._negative_number_matcher.match(option_string):
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1417):         return action
argparse.py(1591):         self._group_actions.append(action)
argparse.py(1592):         return action
argparse.py(1752):         return action
__main__.py(45): parser.add_argument(
__main__.py(46):     "--file_header",
__main__.py(47):     "-f",
__main__.py(48):     default="Peter Rasmussen: Programming Assignment 1",
__main__.py(49):     type=str,
__main__.py(50):     help="Specify file header",
__main__.py(45): parser.add_argument(
 --- modulename: argparse, funcname: add_argument
argparse.py(1346):         chars = self.prefix_chars
argparse.py(1347):         if not args or len(args) == 1 and args[0][0] not in chars:
argparse.py(1354):             kwargs = self._get_optional_kwargs(*args, **kwargs)
 --- modulename: argparse, funcname: _get_optional_kwargs
argparse.py(1480):         option_strings = []
argparse.py(1481):         long_option_strings = []
argparse.py(1482):         for option_string in args:
argparse.py(1484):             if not option_string[0] in self.prefix_chars:
argparse.py(1492):             option_strings.append(option_string)
argparse.py(1493):             if option_string[0] in self.prefix_chars:
argparse.py(1494):                 if len(option_string) > 1:
argparse.py(1495):                     if option_string[1] in self.prefix_chars:
argparse.py(1496):                         long_option_strings.append(option_string)
argparse.py(1482):         for option_string in args:
argparse.py(1484):             if not option_string[0] in self.prefix_chars:
argparse.py(1492):             option_strings.append(option_string)
argparse.py(1493):             if option_string[0] in self.prefix_chars:
argparse.py(1494):                 if len(option_string) > 1:
argparse.py(1495):                     if option_string[1] in self.prefix_chars:
argparse.py(1482):         for option_string in args:
argparse.py(1499):         dest = kwargs.pop('dest', None)
argparse.py(1500):         if dest is None:
argparse.py(1501):             if long_option_strings:
argparse.py(1502):                 dest_option_string = long_option_strings[0]
argparse.py(1505):             dest = dest_option_string.lstrip(self.prefix_chars)
argparse.py(1506):             if not dest:
argparse.py(1509):             dest = dest.replace('-', '_')
argparse.py(1512):         return dict(kwargs, dest=dest, option_strings=option_strings)
argparse.py(1357):         if 'default' not in kwargs:
argparse.py(1365):         action_class = self._pop_action_class(kwargs)
 --- modulename: argparse, funcname: _pop_action_class
argparse.py(1515):         action = kwargs.pop('action', default)
argparse.py(1516):         return self._registry_get('action', action, action)
 --- modulename: argparse, funcname: _registry_get
argparse.py(1313):         return self._registries[registry_name].get(value, default)
argparse.py(1366):         if not callable(action_class):
argparse.py(1368):         action = action_class(**kwargs)
 --- modulename: argparse, funcname: __init__
argparse.py(862):         if nargs == 0:
argparse.py(866):         if const is not None and nargs != OPTIONAL:
argparse.py(868):         super(_StoreAction, self).__init__(
argparse.py(869):             option_strings=option_strings,
argparse.py(870):             dest=dest,
argparse.py(871):             nargs=nargs,
argparse.py(872):             const=const,
argparse.py(873):             default=default,
argparse.py(874):             type=type,
argparse.py(875):             choices=choices,
argparse.py(876):             required=required,
argparse.py(877):             help=help,
argparse.py(878):             metavar=metavar)
argparse.py(868):         super(_StoreAction, self).__init__(
 --- modulename: argparse, funcname: __init__
argparse.py(820):         self.option_strings = option_strings
argparse.py(821):         self.dest = dest
argparse.py(822):         self.nargs = nargs
argparse.py(823):         self.const = const
argparse.py(824):         self.default = default
argparse.py(825):         self.type = type
argparse.py(826):         self.choices = choices
argparse.py(827):         self.required = required
argparse.py(828):         self.help = help
argparse.py(829):         self.metavar = metavar
argparse.py(1371):         type_func = self._registry_get('type', action.type, action.type)
 --- modulename: argparse, funcname: _registry_get
argparse.py(1313):         return self._registries[registry_name].get(value, default)
argparse.py(1372):         if not callable(type_func):
argparse.py(1375):         if type_func is FileType:
argparse.py(1380):         if hasattr(self, "_get_formatter"):
argparse.py(1381):             try:
argparse.py(1382):                 self._get_formatter()._format_args(action, None)
 --- modulename: argparse, funcname: _get_formatter
argparse.py(2481):         return self.formatter_class(prog=self.prog)
 --- modulename: argparse, funcname: __init__
argparse.py(168):         if width is None:
argparse.py(169):             width = _shutil.get_terminal_size().columns
 --- modulename: shutil, funcname: get_terminal_size
shutil.py(1332):     try:
shutil.py(1333):         columns = int(os.environ['COLUMNS'])
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
shutil.py(1334):     except (KeyError, ValueError):
shutil.py(1335):         columns = 0
shutil.py(1337):     try:
shutil.py(1338):         lines = int(os.environ['LINES'])
 --- modulename: os, funcname: __getitem__
os.py(671):         try:
os.py(672):             value = self._data[self.encodekey(key)]
 --- modulename: os, funcname: encode
os.py(749):             if not isinstance(value, str):
os.py(751):             return value.encode(encoding, 'surrogateescape')
os.py(673):         except KeyError:
os.py(675):             raise KeyError(key) from None
shutil.py(1339):     except (KeyError, ValueError):
shutil.py(1340):         lines = 0
shutil.py(1343):     if columns <= 0 or lines <= 0:
shutil.py(1344):         try:
shutil.py(1345):             size = os.get_terminal_size(sys.__stdout__.fileno())
shutil.py(1346):         except (AttributeError, ValueError, OSError):
shutil.py(1349):             size = os.terminal_size(fallback)
shutil.py(1350):         if columns <= 0:
shutil.py(1351):             columns = size.columns
shutil.py(1352):         if lines <= 0:
shutil.py(1353):             lines = size.lines
shutil.py(1355):     return os.terminal_size((columns, lines))
argparse.py(170):             width -= 2
argparse.py(172):         self._prog = prog
argparse.py(173):         self._indent_increment = indent_increment
argparse.py(174):         self._max_help_position = min(max_help_position,
argparse.py(175):                                       max(width - 20, indent_increment * 2))
argparse.py(174):         self._max_help_position = min(max_help_position,
argparse.py(176):         self._width = width
argparse.py(178):         self._current_indent = 0
argparse.py(179):         self._level = 0
argparse.py(180):         self._action_max_length = 0
argparse.py(182):         self._root_section = self._Section(self, None)
 --- modulename: argparse, funcname: __init__
argparse.py(203):             self.formatter = formatter
argparse.py(204):             self.parent = parent
argparse.py(205):             self.heading = heading
argparse.py(206):             self.items = []
argparse.py(183):         self._current_section = self._root_section
argparse.py(185):         self._whitespace_matcher = _re.compile(r'\s+', _re.ASCII)
 --- modulename: re, funcname: compile
re.py(252):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(292):         flags = flags.value
 --- modulename: types, funcname: __get__
types.py(172):         if instance is None:
types.py(176):         elif self.fget is None:
types.py(178):         return self.fget(instance)
 --- modulename: enum, funcname: value
enum.py(756):         return self._value_
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
argparse.py(186):         self._long_break_matcher = _re.compile(r'\n\n\n+')
 --- modulename: re, funcname: compile
re.py(252):     return _compile(pattern, flags)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
 --- modulename: argparse, funcname: _format_args
argparse.py(587):         get_metavar = self._metavar_formatter(action, default_metavar)
 --- modulename: argparse, funcname: _metavar_formatter
argparse.py(571):         if action.metavar is not None:
argparse.py(573):         elif action.choices is not None:
argparse.py(577):             result = default_metavar
argparse.py(579):         def format(tuple_size):
argparse.py(584):         return format
argparse.py(588):         if action.nargs is None:
argparse.py(589):             result = '%s' % get_metavar(1)
 --- modulename: argparse, funcname: format
argparse.py(580):             if isinstance(result, tuple):
argparse.py(583):                 return (result, ) * tuple_size
argparse.py(608):         return result
argparse.py(1386):         return self._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1748):         if action.option_strings:
argparse.py(1749):             self._optionals._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1590):         action = super(_ArgumentGroup, self)._add_action(action)
 --- modulename: argparse, funcname: _add_action
argparse.py(1400):         self._check_conflict(action)
 --- modulename: argparse, funcname: _check_conflict
argparse.py(1530):         confl_optionals = []
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1532):             if option_string in self._option_string_actions:
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1532):             if option_string in self._option_string_actions:
argparse.py(1531):         for option_string in action.option_strings:
argparse.py(1537):         if confl_optionals:
argparse.py(1403):         self._actions.append(action)
argparse.py(1404):         action.container = self
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1408):             self._option_string_actions[option_string] = action
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1408):             self._option_string_actions[option_string] = action
argparse.py(1407):         for option_string in action.option_strings:
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1412):             if self._negative_number_matcher.match(option_string):
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1412):             if self._negative_number_matcher.match(option_string):
argparse.py(1411):         for option_string in action.option_strings:
argparse.py(1417):         return action
argparse.py(1591):         self._group_actions.append(action)
argparse.py(1592):         return action
argparse.py(1752):         return action
__main__.py(52): args = parser.parse_args()
 --- modulename: argparse, funcname: parse_args
argparse.py(1768):         args, argv = self.parse_known_args(args, namespace)
 --- modulename: argparse, funcname: parse_known_args
argparse.py(1775):         if args is None:
argparse.py(1777):             args = _sys.argv[1:]
argparse.py(1783):         if namespace is None:
argparse.py(1784):             namespace = Namespace()
 --- modulename: argparse, funcname: __init__
argparse.py(1241):         for name in kwargs:
argparse.py(1787):         for action in self._actions:
argparse.py(1788):             if action.dest is not SUPPRESS:
argparse.py(1789):                 if not hasattr(namespace, action.dest):
argparse.py(1790):                     if action.default is not SUPPRESS:
argparse.py(1787):         for action in self._actions:
argparse.py(1788):             if action.dest is not SUPPRESS:
argparse.py(1789):                 if not hasattr(namespace, action.dest):
argparse.py(1790):                     if action.default is not SUPPRESS:
argparse.py(1791):                         setattr(namespace, action.dest, action.default)
argparse.py(1787):         for action in self._actions:
argparse.py(1788):             if action.dest is not SUPPRESS:
argparse.py(1789):                 if not hasattr(namespace, action.dest):
argparse.py(1790):                     if action.default is not SUPPRESS:
argparse.py(1791):                         setattr(namespace, action.dest, action.default)
argparse.py(1787):         for action in self._actions:
argparse.py(1788):             if action.dest is not SUPPRESS:
argparse.py(1789):                 if not hasattr(namespace, action.dest):
argparse.py(1790):                     if action.default is not SUPPRESS:
argparse.py(1791):                         setattr(namespace, action.dest, action.default)
argparse.py(1787):         for action in self._actions:
argparse.py(1788):             if action.dest is not SUPPRESS:
argparse.py(1789):                 if not hasattr(namespace, action.dest):
argparse.py(1790):                     if action.default is not SUPPRESS:
argparse.py(1791):                         setattr(namespace, action.dest, action.default)
argparse.py(1787):         for action in self._actions:
argparse.py(1794):         for dest in self._defaults:
argparse.py(1799):         try:
argparse.py(1800):             namespace, args = self._parse_known_args(args, namespace)
 --- modulename: argparse, funcname: _parse_known_args
argparse.py(1811):         if self.fromfile_prefix_chars is not None:
argparse.py(1816):         action_conflicts = {}
argparse.py(1817):         for mutex_group in self._mutually_exclusive_groups:
argparse.py(1827):         option_string_indices = {}
argparse.py(1828):         arg_string_pattern_parts = []
argparse.py(1829):         arg_strings_iter = iter(arg_strings)
argparse.py(1830):         for i, arg_string in enumerate(arg_strings_iter):
argparse.py(1833):             if arg_string == '--':
argparse.py(1841):                 option_tuple = self._parse_optional(arg_string)
 --- modulename: argparse, funcname: _parse_optional
argparse.py(2124):         if not arg_string:
argparse.py(2128):         if not arg_string[0] in self.prefix_chars:
argparse.py(2132):         if arg_string in self._option_string_actions:
argparse.py(2133):             action = self._option_string_actions[arg_string]
argparse.py(2134):             return action, arg_string, None
argparse.py(1842):                 if option_tuple is None:
argparse.py(1845):                     option_string_indices[i] = option_tuple
argparse.py(1846):                     pattern = 'O'
argparse.py(1847):                 arg_string_pattern_parts.append(pattern)
argparse.py(1830):         for i, arg_string in enumerate(arg_strings_iter):
argparse.py(1833):             if arg_string == '--':
argparse.py(1841):                 option_tuple = self._parse_optional(arg_string)
 --- modulename: argparse, funcname: _parse_optional
argparse.py(2124):         if not arg_string:
argparse.py(2128):         if not arg_string[0] in self.prefix_chars:
argparse.py(2129):             return None
argparse.py(1842):                 if option_tuple is None:
argparse.py(1843):                     pattern = 'A'
argparse.py(1847):                 arg_string_pattern_parts.append(pattern)
argparse.py(1830):         for i, arg_string in enumerate(arg_strings_iter):
argparse.py(1833):             if arg_string == '--':
argparse.py(1841):                 option_tuple = self._parse_optional(arg_string)
 --- modulename: argparse, funcname: _parse_optional
argparse.py(2124):         if not arg_string:
argparse.py(2128):         if not arg_string[0] in self.prefix_chars:
argparse.py(2132):         if arg_string in self._option_string_actions:
argparse.py(2133):             action = self._option_string_actions[arg_string]
argparse.py(2134):             return action, arg_string, None
argparse.py(1842):                 if option_tuple is None:
argparse.py(1845):                     option_string_indices[i] = option_tuple
argparse.py(1846):                     pattern = 'O'
argparse.py(1847):                 arg_string_pattern_parts.append(pattern)
argparse.py(1830):         for i, arg_string in enumerate(arg_strings_iter):
argparse.py(1833):             if arg_string == '--':
argparse.py(1841):                 option_tuple = self._parse_optional(arg_string)
 --- modulename: argparse, funcname: _parse_optional
argparse.py(2124):         if not arg_string:
argparse.py(2128):         if not arg_string[0] in self.prefix_chars:
argparse.py(2129):             return None
argparse.py(1842):                 if option_tuple is None:
argparse.py(1843):                     pattern = 'A'
argparse.py(1847):                 arg_string_pattern_parts.append(pattern)
argparse.py(1830):         for i, arg_string in enumerate(arg_strings_iter):
argparse.py(1850):         arg_strings_pattern = ''.join(arg_string_pattern_parts)
argparse.py(1853):         seen_actions = set()
argparse.py(1854):         seen_non_default_actions = set()
argparse.py(1856):         def take_action(action, argument_strings, option_string=None):
argparse.py(1877):         def consume_optional(start_index):
argparse.py(1951):         positionals = self._get_positional_actions()
 --- modulename: argparse, funcname: _get_positional_actions
argparse.py(1760):         return [action
argparse.py(1761):                 for action in self._actions
argparse.py(1760):         return [action
 --- modulename: argparse, funcname: <listcomp>
argparse.py(1760):         return [action
argparse.py(1761):                 for action in self._actions
argparse.py(1762):                 if not action.option_strings]
argparse.py(1760):         return [action
argparse.py(1761):                 for action in self._actions
argparse.py(1762):                 if not action.option_strings]
argparse.py(1760):         return [action
argparse.py(1761):                 for action in self._actions
argparse.py(1762):                 if not action.option_strings]
argparse.py(1760):         return [action
argparse.py(1761):                 for action in self._actions
argparse.py(1762):                 if not action.option_strings]
argparse.py(1760):         return [action
argparse.py(1761):                 for action in self._actions
argparse.py(1762):                 if not action.option_strings]
argparse.py(1760):         return [action
argparse.py(1954):         def consume_positionals(start_index):
argparse.py(1974):         extras = []
argparse.py(1975):         start_index = 0
argparse.py(1976):         if option_string_indices:
argparse.py(1977):             max_option_string_index = max(option_string_indices)
argparse.py(1980):         while start_index <= max_option_string_index:
argparse.py(1983):             next_option_string_index = min([
argparse.py(1985):                 for index in option_string_indices
argparse.py(1983):             next_option_string_index = min([
 --- modulename: argparse, funcname: <listcomp>
argparse.py(1983):             next_option_string_index = min([
argparse.py(1985):                 for index in option_string_indices
argparse.py(1986):                 if index >= start_index])
argparse.py(1984):                 index
argparse.py(1983):             next_option_string_index = min([
argparse.py(1985):                 for index in option_string_indices
argparse.py(1986):                 if index >= start_index])
argparse.py(1984):                 index
argparse.py(1983):             next_option_string_index = min([
argparse.py(1987):             if start_index != next_option_string_index:
argparse.py(2000):             if start_index not in option_string_indices:
argparse.py(2006):             start_index = consume_optional(start_index)
 --- modulename: argparse, funcname: consume_optional
argparse.py(1880):             option_tuple = option_string_indices[start_index]
argparse.py(1881):             action, option_string, explicit_arg = option_tuple
argparse.py(1885):             match_argument = self._match_argument
argparse.py(1886):             action_tuples = []
argparse.py(1890):                 if action is None:
argparse.py(1896):                 if explicit_arg is not None:
argparse.py(1934):                     start = start_index + 1
argparse.py(1935):                     selected_patterns = arg_strings_pattern[start:]
argparse.py(1936):                     arg_count = match_argument(action, selected_patterns)
 --- modulename: argparse, funcname: _match_argument
argparse.py(2086):         nargs_pattern = self._get_nargs_pattern(action)
 --- modulename: argparse, funcname: _get_nargs_pattern
argparse.py(2228):         nargs = action.nargs
argparse.py(2231):         if nargs is None:
argparse.py(2232):             nargs_pattern = '(-*A-*)'
argparse.py(2263):         if action.option_strings:
argparse.py(2264):             nargs_pattern = nargs_pattern.replace('-*', '')
argparse.py(2265):             nargs_pattern = nargs_pattern.replace('-', '')
argparse.py(2268):         return nargs_pattern
argparse.py(2087):         match = _re.match(nargs_pattern, arg_strings_pattern)
 --- modulename: re, funcname: match
re.py(191):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
re.py(295):     except KeyError:
re.py(296):         pass
re.py(297):     if isinstance(pattern, Pattern):
re.py(302):     if not sre_compile.isstring(pattern):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(596):     return isinstance(obj, (str, bytes))
re.py(304):     p = sre_compile.compile(pattern, flags)
 --- modulename: sre_compile, funcname: compile
sre_compile.py(762):     if isstring(p):
 --- modulename: sre_compile, funcname: isstring
sre_compile.py(596):     return isinstance(obj, (str, bytes))
sre_compile.py(763):         pattern = p
sre_compile.py(764):         p = sre_parse.parse(p, flags)
 --- modulename: sre_parse, funcname: parse
sre_parse.py(940):     source = Tokenizer(str)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(225):         self.istext = isinstance(string, str)
sre_parse.py(226):         self.string = string
sre_parse.py(227):         if not self.istext:
sre_parse.py(229):         self.decoded_string = string
sre_parse.py(230):         self.index = 0
sre_parse.py(231):         self.next = None
sre_parse.py(232):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(234):         index = self.index
sre_parse.py(235):         try:
sre_parse.py(236):             char = self.decoded_string[index]
sre_parse.py(240):         if char == "\\":
sre_parse.py(247):         self.index = index + 1
sre_parse.py(248):         self.next = char
sre_parse.py(942):     if state is None:
sre_parse.py(943):         state = State()
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(77):         self.flags = 0
sre_parse.py(78):         self.groupdict = {}
sre_parse.py(79):         self.groupwidths = [None]  # group 0
sre_parse.py(80):         self.lookbehindgroups = None
sre_parse.py(944):     state.flags = flags
sre_parse.py(945):     state.str = str
sre_parse.py(947):     try:
sre_parse.py(948):         p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(438):     items = []
sre_parse.py(439):     itemsappend = items.append
sre_parse.py(440):     sourcematch = source.match
sre_parse.py(441):     start = source.tell()
 --- modulename: sre_parse, funcname: tell
sre_parse.py(287):         return self.index - len(self.next or '')
sre_parse.py(443):         itemsappend(_parse(source, state, verbose, nested + 1,
sre_parse.py(444):                            not nested and not items))
sre_parse.py(443):         itemsappend(_parse(source, state, verbose, nested + 1,
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(495):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(112):         self.state = state
sre_parse.py(113):         if data is None:
sre_parse.py(114):             data = []
sre_parse.py(115):         self.data = data
sre_parse.py(116):         self.width = None
sre_parse.py(498):     subpatternappend = subpattern.append
sre_parse.py(499):     sourceget = source.get
sre_parse.py(500):     sourcematch = source.match
sre_parse.py(501):     _len = len
sre_parse.py(502):     _ord = ord
sre_parse.py(506):         this = source.next
sre_parse.py(507):         if this is None:
sre_parse.py(509):         if this in "|)":
sre_parse.py(511):         sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(255):         this = self.next
sre_parse.py(256):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(234):         index = self.index
sre_parse.py(235):         try:
sre_parse.py(236):             char = self.decoded_string[index]
sre_parse.py(240):         if char == "\\":
sre_parse.py(247):         self.index = index + 1
sre_parse.py(248):         self.next = char
sre_parse.py(257):         return this
sre_parse.py(513):         if verbose:
sre_parse.py(524):         if this[0] == "\\":
sre_parse.py(528):         elif this not in SPECIAL_CHARS:
sre_parse.py(531):         elif this == "[":
sre_parse.py(620):         elif this in REPEAT_CHARS:
sre_parse.py(682):         elif this == ".":
sre_parse.py(685):         elif this == "(":
sre_parse.py(686):             start = source.tell() - 1
 --- modulename: sre_parse, funcname: tell
sre_parse.py(287):         return self.index - len(self.next or '')
sre_parse.py(687):             group = True
sre_parse.py(688):             name = None
sre_parse.py(689):             add_flags = 0
sre_parse.py(690):             del_flags = 0
sre_parse.py(691):             if sourcematch("?"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(250):         if char == self.next:
sre_parse.py(253):         return False
sre_parse.py(827):             if group is not None:
sre_parse.py(828):                 try:
sre_parse.py(829):                     group = state.opengroup(name)
 --- modulename: sre_parse, funcname: opengroup
sre_parse.py(85):         gid = self.groups
 --- modulename: sre_parse, funcname: groups
sre_parse.py(83):         return len(self.groupwidths)
sre_parse.py(86):         self.groupwidths.append(None)
sre_parse.py(87):         if self.groups > MAXGROUPS:
 --- modulename: sre_parse, funcname: groups
sre_parse.py(83):         return len(self.groupwidths)
sre_parse.py(89):         if name is not None:
sre_parse.py(95):         return gid
sre_parse.py(832):             sub_verbose = ((verbose or (add_flags & SRE_FLAG_VERBOSE)) and
sre_parse.py(832):             sub_verbose = ((verbose or (add_flags & SRE_FLAG_VERBOSE)) and
sre_parse.py(834):             p = _parse_sub(source, state, sub_verbose, nested + 1)
 --- modulename: sre_parse, funcname: _parse_sub
sre_parse.py(438):     items = []
sre_parse.py(439):     itemsappend = items.append
sre_parse.py(440):     sourcematch = source.match
sre_parse.py(441):     start = source.tell()
 --- modulename: sre_parse, funcname: tell
sre_parse.py(287):         return self.index - len(self.next or '')
sre_parse.py(443):         itemsappend(_parse(source, state, verbose, nested + 1,
sre_parse.py(444):                            not nested and not items))
sre_parse.py(443):         itemsappend(_parse(source, state, verbose, nested + 1,
 --- modulename: sre_parse, funcname: _parse
sre_parse.py(495):     subpattern = SubPattern(state)
 --- modulename: sre_parse, funcname: __init__
sre_parse.py(112):         self.state = state
sre_parse.py(113):         if data is None:
sre_parse.py(114):             data = []
sre_parse.py(115):         self.data = data
sre_parse.py(116):         self.width = None
sre_parse.py(498):     subpatternappend = subpattern.append
sre_parse.py(499):     sourceget = source.get
sre_parse.py(500):     sourcematch = source.match
sre_parse.py(501):     _len = len
sre_parse.py(502):     _ord = ord
sre_parse.py(506):         this = source.next
sre_parse.py(507):         if this is None:
sre_parse.py(509):         if this in "|)":
sre_parse.py(511):         sourceget()
 --- modulename: sre_parse, funcname: get
sre_parse.py(255):         this = self.next
sre_parse.py(256):         self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(234):         index = self.index
sre_parse.py(235):         try:
sre_parse.py(236):             char = self.decoded_string[index]
sre_parse.py(240):         if char == "\\":
sre_parse.py(247):         self.index = index + 1
sre_parse.py(248):         self.next = char
sre_parse.py(257):         return this
sre_parse.py(513):         if verbose:
sre_parse.py(524):         if this[0] == "\\":
sre_parse.py(528):         elif this not in SPECIAL_CHARS:
sre_parse.py(529):             subpatternappend((LITERAL, _ord(this)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(173):         self.data.append(code)
sre_parse.py(506):         this = source.next
sre_parse.py(507):         if this is None:
sre_parse.py(509):         if this in "|)":
sre_parse.py(510):             break # end of subpattern
sre_parse.py(852):     for i in range(len(subpattern))[::-1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(161):         return len(self.data)
sre_parse.py(853):         op, av = subpattern[i]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(165):         if isinstance(index, slice):
sre_parse.py(167):         return self.data[index]
sre_parse.py(854):         if op is SUBPATTERN:
sre_parse.py(852):     for i in range(len(subpattern))[::-1]:
sre_parse.py(859):     return subpattern
sre_parse.py(445):         if not sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(250):         if char == self.next:
sre_parse.py(253):         return False
sre_parse.py(446):             break
sre_parse.py(448):     if len(items) == 1:
sre_parse.py(449):         return items[0]
sre_parse.py(835):             if not source.match(")"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(250):         if char == self.next:
sre_parse.py(251):             self.__next()
 --- modulename: sre_parse, funcname: __next
sre_parse.py(234):         index = self.index
sre_parse.py(235):         try:
sre_parse.py(236):             char = self.decoded_string[index]
sre_parse.py(237):         except IndexError:
sre_parse.py(238):             self.next = None
sre_parse.py(239):             return
sre_parse.py(252):             return True
sre_parse.py(838):             if group is not None:
sre_parse.py(839):                 state.closegroup(group, p)
 --- modulename: sre_parse, funcname: closegroup
sre_parse.py(97):         self.groupwidths[gid] = p.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(176):         if self.width is not None:
sre_parse.py(178):         lo = hi = 0
sre_parse.py(179):         for op, av in self.data:
sre_parse.py(180):             if op is BRANCH:
sre_parse.py(189):             elif op is CALL:
sre_parse.py(193):             elif op is SUBPATTERN:
sre_parse.py(197):             elif op in _REPEATCODES:
sre_parse.py(201):             elif op in _UNITCODES:
sre_parse.py(202):                 lo = lo + 1
sre_parse.py(203):                 hi = hi + 1
sre_parse.py(179):         for op, av in self.data:
sre_parse.py(220):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(221):         return self.width
sre_parse.py(840):             subpatternappend((SUBPATTERN, (group, add_flags, del_flags, p)))
 --- modulename: sre_parse, funcname: append
sre_parse.py(173):         self.data.append(code)
sre_parse.py(506):         this = source.next
sre_parse.py(507):         if this is None:
sre_parse.py(508):             break # end of pattern
sre_parse.py(852):     for i in range(len(subpattern))[::-1]:
 --- modulename: sre_parse, funcname: __len__
sre_parse.py(161):         return len(self.data)
sre_parse.py(853):         op, av = subpattern[i]
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(165):         if isinstance(index, slice):
sre_parse.py(167):         return self.data[index]
sre_parse.py(854):         if op is SUBPATTERN:
sre_parse.py(855):             group, add_flags, del_flags, p = av
sre_parse.py(856):             if group is None and not add_flags and not del_flags:
sre_parse.py(852):     for i in range(len(subpattern))[::-1]:
sre_parse.py(859):     return subpattern
sre_parse.py(445):         if not sourcematch("|"):
 --- modulename: sre_parse, funcname: match
sre_parse.py(250):         if char == self.next:
sre_parse.py(253):         return False
sre_parse.py(446):             break
sre_parse.py(448):     if len(items) == 1:
sre_parse.py(449):         return items[0]
sre_parse.py(958):     p.state.flags = fix_flags(str, p.state.flags)
 --- modulename: sre_parse, funcname: fix_flags
sre_parse.py(923):     if isinstance(src, str):
sre_parse.py(924):         if flags & SRE_FLAG_LOCALE:
sre_parse.py(926):         if not flags & SRE_FLAG_ASCII:
sre_parse.py(927):             flags |= SRE_FLAG_UNICODE
sre_parse.py(935):     return flags
sre_parse.py(960):     if source.next is not None:
sre_parse.py(964):     if flags & SRE_FLAG_DEBUG:
sre_parse.py(967):     return p
sre_compile.py(768):     code = _code(p, flags)
 --- modulename: sre_compile, funcname: _code
sre_compile.py(600):     flags = p.state.flags | flags
sre_compile.py(601):     code = []
sre_compile.py(604):     _compile_info(code, p, flags)
 --- modulename: sre_compile, funcname: _compile_info
sre_compile.py(540):     lo, hi = pattern.getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(176):         if self.width is not None:
sre_parse.py(178):         lo = hi = 0
sre_parse.py(179):         for op, av in self.data:
sre_parse.py(180):             if op is BRANCH:
sre_parse.py(189):             elif op is CALL:
sre_parse.py(193):             elif op is SUBPATTERN:
sre_parse.py(194):                 i, j = av[-1].getwidth()
 --- modulename: sre_parse, funcname: getwidth
sre_parse.py(176):         if self.width is not None:
sre_parse.py(177):             return self.width
sre_parse.py(195):                 lo = lo + i
sre_parse.py(196):                 hi = hi + j
sre_parse.py(179):         for op, av in self.data:
sre_parse.py(220):         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
sre_parse.py(221):         return self.width
sre_compile.py(541):     if hi > MAXCODE:
sre_compile.py(543):     if lo == 0:
sre_compile.py(547):     prefix = []
sre_compile.py(548):     prefix_skip = 0
sre_compile.py(549):     charset = [] # not used
sre_compile.py(550):     if not (flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE):
sre_compile.py(552):         prefix, prefix_skip, got_all = _get_literal_prefix(pattern, flags)
 --- modulename: sre_compile, funcname: _get_literal_prefix
sre_compile.py(463):     prefix = []
sre_compile.py(464):     prefixappend = prefix.append
sre_compile.py(465):     prefix_skip = None
sre_compile.py(466):     iscased = _get_iscased(flags)
 --- modulename: sre_compile, funcname: _get_iscased
sre_compile.py(454):     if not flags & SRE_FLAG_IGNORECASE:
sre_compile.py(455):         return None
sre_compile.py(467):     for op, av in pattern.data:
sre_compile.py(468):         if op is LITERAL:
sre_compile.py(472):         elif op is SUBPATTERN:
sre_compile.py(473):             group, add_flags, del_flags, p = av
sre_compile.py(474):             flags1 = _combine_flags(flags, add_flags, del_flags)
 --- modulename: sre_compile, funcname: _combine_flags
sre_compile.py(67):     if add_flags & TYPE_FLAGS:
sre_compile.py(69):     return (flags | add_flags) & ~del_flags
sre_compile.py(475):             if flags1 & SRE_FLAG_IGNORECASE and flags1 & SRE_FLAG_LOCALE:
sre_compile.py(477):             prefix1, prefix_skip1, got_all = _get_literal_prefix(p, flags1)
 --- modulename: sre_compile, funcname: _get_literal_prefix
sre_compile.py(463):     prefix = []
sre_compile.py(464):     prefixappend = prefix.append
sre_compile.py(465):     prefix_skip = None
sre_compile.py(466):     iscased = _get_iscased(flags)
 --- modulename: sre_compile, funcname: _get_iscased
sre_compile.py(454):     if not flags & SRE_FLAG_IGNORECASE:
sre_compile.py(455):         return None
sre_compile.py(467):     for op, av in pattern.data:
sre_compile.py(468):         if op is LITERAL:
sre_compile.py(469):             if iscased and iscased(av):
sre_compile.py(471):             prefixappend(av)
sre_compile.py(467):     for op, av in pattern.data:
sre_compile.py(489):         return prefix, prefix_skip, True
sre_compile.py(478):             if prefix_skip is None:
sre_compile.py(479):                 if group is not None:
sre_compile.py(480):                     prefix_skip = len(prefix)
sre_compile.py(483):             prefix.extend(prefix1)
sre_compile.py(484):             if not got_all:
sre_compile.py(467):     for op, av in pattern.data:
sre_compile.py(489):         return prefix, prefix_skip, True
sre_compile.py(554):         if not prefix:
sre_compile.py(561):     emit = code.append
sre_compile.py(562):     emit(INFO)
sre_compile.py(563):     skip = len(code); emit(0)
sre_compile.py(565):     mask = 0
sre_compile.py(566):     if prefix:
sre_compile.py(567):         mask = SRE_INFO_PREFIX
sre_compile.py(568):         if prefix_skip is None and got_all:
sre_compile.py(572):     emit(mask)
sre_compile.py(574):     if lo < MAXCODE:
sre_compile.py(575):         emit(lo)
sre_compile.py(579):     emit(min(hi, MAXCODE))
sre_compile.py(581):     if prefix:
sre_compile.py(582):         emit(len(prefix)) # length
sre_compile.py(583):         if prefix_skip is None:
sre_compile.py(585):         emit(prefix_skip) # skip
sre_compile.py(586):         code.extend(prefix)
sre_compile.py(588):         code.extend(_generate_overlap_table(prefix))
 --- modulename: sre_compile, funcname: _generate_overlap_table
sre_compile.py(441):     table = [0] * len(prefix)
sre_compile.py(442):     for i in range(1, len(prefix)):
sre_compile.py(451):     return table
sre_compile.py(593):     code[skip] = len(code) - skip
sre_compile.py(607):     _compile(code, p.data, flags)
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(73):     emit = code.append
sre_compile.py(74):     _len = len
sre_compile.py(75):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(76):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(77):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(78):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(79):     iscased = None
sre_compile.py(80):     tolower = None
sre_compile.py(81):     fixes = None
sre_compile.py(82):     if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:
sre_compile.py(90):     for op, av in pattern:
sre_compile.py(91):         if op in LITERAL_CODES:
sre_compile.py(119):         elif op is IN:
sre_compile.py(132):         elif op is ANY:
sre_compile.py(137):         elif op in REPEATING_CODES:
sre_compile.py(162):         elif op is SUBPATTERN:
sre_compile.py(163):             group, add_flags, del_flags, p = av
sre_compile.py(164):             if group:
sre_compile.py(165):                 emit(MARK)
sre_compile.py(166):                 emit((group-1)*2)
sre_compile.py(168):             _compile(code, p, _combine_flags(flags, add_flags, del_flags))
 --- modulename: sre_compile, funcname: _combine_flags
sre_compile.py(67):     if add_flags & TYPE_FLAGS:
sre_compile.py(69):     return (flags | add_flags) & ~del_flags
 --- modulename: sre_compile, funcname: _compile
sre_compile.py(73):     emit = code.append
sre_compile.py(74):     _len = len
sre_compile.py(75):     LITERAL_CODES = _LITERAL_CODES
sre_compile.py(76):     REPEATING_CODES = _REPEATING_CODES
sre_compile.py(77):     SUCCESS_CODES = _SUCCESS_CODES
sre_compile.py(78):     ASSERT_CODES = _ASSERT_CODES
sre_compile.py(79):     iscased = None
sre_compile.py(80):     tolower = None
sre_compile.py(81):     fixes = None
sre_compile.py(82):     if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:
sre_compile.py(90):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(165):         if isinstance(index, slice):
sre_parse.py(167):         return self.data[index]
sre_compile.py(91):         if op in LITERAL_CODES:
sre_compile.py(92):             if not flags & SRE_FLAG_IGNORECASE:
sre_compile.py(93):                 emit(op)
sre_compile.py(94):                 emit(av)
sre_compile.py(90):     for op, av in pattern:
 --- modulename: sre_parse, funcname: __getitem__
sre_parse.py(165):         if isinstance(index, slice):
sre_parse.py(167):         return self.data[index]
sre_compile.py(169):             if group:
sre_compile.py(170):                 emit(MARK)
sre_compile.py(171):                 emit((group-1)*2+1)
sre_compile.py(90):     for op, av in pattern:
sre_compile.py(609):     code.append(SUCCESS)
sre_compile.py(611):     return code
sre_compile.py(770):     if flags & SRE_FLAG_DEBUG:
sre_compile.py(775):     groupindex = p.state.groupdict
sre_compile.py(776):     indexgroup = [None] * p.state.groups
 --- modulename: sre_parse, funcname: groups
sre_parse.py(83):         return len(self.groupwidths)
sre_compile.py(777):     for k, i in groupindex.items():
sre_compile.py(780):     return _sre.compile(
sre_compile.py(781):         pattern, flags | p.state.flags, code,
sre_compile.py(782):         p.state.groups-1,
 --- modulename: sre_parse, funcname: groups
sre_parse.py(83):         return len(self.groupwidths)
sre_compile.py(783):         groupindex, tuple(indexgroup)
sre_compile.py(780):     return _sre.compile(
re.py(305):     if not (flags & DEBUG):
 --- modulename: enum, funcname: __and__
enum.py(939):         if not isinstance(other, (self.__class__, int)):
enum.py(941):         return self.__class__(self._value_ & self.__class__(other)._value_)
 --- modulename: enum, funcname: __call__
enum.py(338):         if names is None:  # simple value lookup
enum.py(339):             return cls.__new__(cls, value)
 --- modulename: enum, funcname: __new__
enum.py(635):         if type(value) is cls:
enum.py(640):         try:
enum.py(641):             return cls._value2member_map_[value]
 --- modulename: enum, funcname: __call__
enum.py(338):         if names is None:  # simple value lookup
enum.py(339):             return cls.__new__(cls, value)
 --- modulename: enum, funcname: __new__
enum.py(635):         if type(value) is cls:
enum.py(640):         try:
enum.py(641):             return cls._value2member_map_[value]
re.py(306):         if len(_cache) >= _MAXCACHE:
re.py(312):         _cache[type(pattern), pattern, flags] = p
re.py(313):     return p
argparse.py(2090):         if match is None:
argparse.py(2104):         return len(match.group(1))
argparse.py(1937):                     stop = start + arg_count
argparse.py(1938):                     args = arg_strings[start:stop]
argparse.py(1939):                     action_tuples.append((action, args, option_string))
argparse.py(1940):                     break
argparse.py(1944):             assert action_tuples
argparse.py(1945):             for action, args, option_string in action_tuples:
argparse.py(1946):                 take_action(action, args, option_string)
 --- modulename: argparse, funcname: take_action
argparse.py(1857):             seen_actions.add(action)
argparse.py(1858):             argument_values = self._get_values(action, argument_strings)
 --- modulename: argparse, funcname: _get_values
argparse.py(2360):         if action.nargs not in [PARSER, REMAINDER]:
argparse.py(2361):             try:
argparse.py(2362):                 arg_strings.remove('--')
argparse.py(2363):             except ValueError:
argparse.py(2364):                 pass
argparse.py(2367):         if not arg_strings and action.nargs == OPTIONAL:
argparse.py(2378):         elif (not arg_strings and action.nargs == ZERO_OR_MORE and
argparse.py(2387):         elif len(arg_strings) == 1 and action.nargs in [None, OPTIONAL]:
argparse.py(2388):             arg_string, = arg_strings
argparse.py(2389):             value = self._get_value(action, arg_string)
 --- modulename: argparse, funcname: _get_value
argparse.py(2415):         type_func = self._registry_get('type', action.type, action.type)
 --- modulename: argparse, funcname: _registry_get
argparse.py(1313):         return self._registries[registry_name].get(value, default)
argparse.py(2416):         if not callable(type_func):
argparse.py(2421):         try:
argparse.py(2422):             result = type_func(arg_string)
 --- modulename: pathlib, funcname: __new__
pathlib.py(1040):         if cls is Path:
pathlib.py(1041):             cls = WindowsPath if os.name == 'nt' else PosixPath
pathlib.py(1042):         self = cls._from_parts(args, init=False)
 --- modulename: pathlib, funcname: _from_parts
pathlib.py(682):         self = object.__new__(cls)
pathlib.py(683):         drv, root, parts = self._parse_args(args)
 --- modulename: pathlib, funcname: _parse_args
pathlib.py(662):         parts = []
pathlib.py(663):         for a in args:
pathlib.py(664):             if isinstance(a, PurePath):
pathlib.py(667):                 a = os.fspath(a)
pathlib.py(668):                 if isinstance(a, str):
pathlib.py(670):                     parts.append(str(a))
pathlib.py(663):         for a in args:
pathlib.py(676):         return cls._flavour.parse_parts(parts)
 --- modulename: pathlib, funcname: parse_parts
pathlib.py(65):         parsed = []
pathlib.py(66):         sep = self.sep
pathlib.py(67):         altsep = self.altsep
pathlib.py(68):         drv = root = ''
pathlib.py(69):         it = reversed(parts)
pathlib.py(70):         for part in it:
pathlib.py(71):             if not part:
pathlib.py(73):             if altsep:
pathlib.py(75):             drv, root, rel = self.splitroot(part)
 --- modulename: pathlib, funcname: splitroot
pathlib.py(294):         if part and part[0] == sep:
pathlib.py(306):             return '', '', part
pathlib.py(76):             if sep in rel:
pathlib.py(77):                 for x in reversed(rel.split(sep)):
pathlib.py(78):                     if x and x != '.':
pathlib.py(79):                         parsed.append(sys.intern(x))
pathlib.py(77):                 for x in reversed(rel.split(sep)):
pathlib.py(78):                     if x and x != '.':
pathlib.py(79):                         parsed.append(sys.intern(x))
pathlib.py(77):                 for x in reversed(rel.split(sep)):
pathlib.py(78):                     if x and x != '.':
pathlib.py(79):                         parsed.append(sys.intern(x))
pathlib.py(77):                 for x in reversed(rel.split(sep)):
pathlib.py(83):             if drv or root:
pathlib.py(70):         for part in it:
pathlib.py(97):         if drv or root:
pathlib.py(99):         parsed.reverse()
pathlib.py(100):         return drv, root, parsed
pathlib.py(684):         self._drv = drv
pathlib.py(685):         self._root = root
pathlib.py(686):         self._parts = parts
pathlib.py(687):         if init:
pathlib.py(689):         return self
pathlib.py(1043):         if not self._flavour.is_supported:
pathlib.py(1046):         self._init()
 --- modulename: pathlib, funcname: _init
pathlib.py(1053):         self._closed = False
pathlib.py(1054):         if template is not None:
pathlib.py(1057):             self._accessor = _normal_accessor
pathlib.py(1047):         return self
argparse.py(2438):         return result
argparse.py(2390):             self._check_value(action, value)
 --- modulename: argparse, funcname: _check_value
argparse.py(2442):         if action.choices is not None and value not in action.choices:
argparse.py(2412):         return value
argparse.py(1863):             if argument_values is not action.default:
argparse.py(1864):                 seen_non_default_actions.add(action)
argparse.py(1865):                 for conflict_action in action_conflicts.get(action, []):
argparse.py(1873):             if argument_values is not SUPPRESS:
argparse.py(1874):                 action(self, namespace, argument_values, option_string)
 --- modulename: argparse, funcname: __call__
argparse.py(881):         setattr(namespace, self.dest, values)
argparse.py(1945):             for action, args, option_string in action_tuples:
argparse.py(1947):             return stop
argparse.py(1980):         while start_index <= max_option_string_index:
argparse.py(1983):             next_option_string_index = min([
argparse.py(1985):                 for index in option_string_indices
argparse.py(1983):             next_option_string_index = min([
 --- modulename: argparse, funcname: <listcomp>
argparse.py(1983):             next_option_string_index = min([
argparse.py(1985):                 for index in option_string_indices
argparse.py(1986):                 if index >= start_index])
argparse.py(1983):             next_option_string_index = min([
argparse.py(1985):                 for index in option_string_indices
argparse.py(1986):                 if index >= start_index])
argparse.py(1984):                 index
argparse.py(1983):             next_option_string_index = min([
argparse.py(1987):             if start_index != next_option_string_index:
argparse.py(2000):             if start_index not in option_string_indices:
argparse.py(2006):             start_index = consume_optional(start_index)
 --- modulename: argparse, funcname: consume_optional
argparse.py(1880):             option_tuple = option_string_indices[start_index]
argparse.py(1881):             action, option_string, explicit_arg = option_tuple
argparse.py(1885):             match_argument = self._match_argument
argparse.py(1886):             action_tuples = []
argparse.py(1890):                 if action is None:
argparse.py(1896):                 if explicit_arg is not None:
argparse.py(1934):                     start = start_index + 1
argparse.py(1935):                     selected_patterns = arg_strings_pattern[start:]
argparse.py(1936):                     arg_count = match_argument(action, selected_patterns)
 --- modulename: argparse, funcname: _match_argument
argparse.py(2086):         nargs_pattern = self._get_nargs_pattern(action)
 --- modulename: argparse, funcname: _get_nargs_pattern
argparse.py(2228):         nargs = action.nargs
argparse.py(2231):         if nargs is None:
argparse.py(2232):             nargs_pattern = '(-*A-*)'
argparse.py(2263):         if action.option_strings:
argparse.py(2264):             nargs_pattern = nargs_pattern.replace('-*', '')
argparse.py(2265):             nargs_pattern = nargs_pattern.replace('-', '')
argparse.py(2268):         return nargs_pattern
argparse.py(2087):         match = _re.match(nargs_pattern, arg_strings_pattern)
 --- modulename: re, funcname: match
re.py(191):     return _compile(pattern, flags).match(string)
 --- modulename: re, funcname: _compile
re.py(291):     if isinstance(flags, RegexFlag):
re.py(293):     try:
re.py(294):         return _cache[type(pattern), pattern, flags]
argparse.py(2090):         if match is None:
argparse.py(2104):         return len(match.group(1))
argparse.py(1937):                     stop = start + arg_count
argparse.py(1938):                     args = arg_strings[start:stop]
argparse.py(1939):                     action_tuples.append((action, args, option_string))
argparse.py(1940):                     break
argparse.py(1944):             assert action_tuples
argparse.py(1945):             for action, args, option_string in action_tuples:
argparse.py(1946):                 take_action(action, args, option_string)
 --- modulename: argparse, funcname: take_action
argparse.py(1857):             seen_actions.add(action)
argparse.py(1858):             argument_values = self._get_values(action, argument_strings)
 --- modulename: argparse, funcname: _get_values
argparse.py(2360):         if action.nargs not in [PARSER, REMAINDER]:
argparse.py(2361):             try:
argparse.py(2362):                 arg_strings.remove('--')
argparse.py(2363):             except ValueError:
argparse.py(2364):                 pass
argparse.py(2367):         if not arg_strings and action.nargs == OPTIONAL:
argparse.py(2378):         elif (not arg_strings and action.nargs == ZERO_OR_MORE and
argparse.py(2387):         elif len(arg_strings) == 1 and action.nargs in [None, OPTIONAL]:
argparse.py(2388):             arg_string, = arg_strings
argparse.py(2389):             value = self._get_value(action, arg_string)
 --- modulename: argparse, funcname: _get_value
argparse.py(2415):         type_func = self._registry_get('type', action.type, action.type)
 --- modulename: argparse, funcname: _registry_get
argparse.py(1313):         return self._registries[registry_name].get(value, default)
argparse.py(2416):         if not callable(type_func):
argparse.py(2421):         try:
argparse.py(2422):             result = type_func(arg_string)
 --- modulename: pathlib, funcname: __new__
pathlib.py(1040):         if cls is Path:
pathlib.py(1041):             cls = WindowsPath if os.name == 'nt' else PosixPath
pathlib.py(1042):         self = cls._from_parts(args, init=False)
 --- modulename: pathlib, funcname: _from_parts
pathlib.py(682):         self = object.__new__(cls)
pathlib.py(683):         drv, root, parts = self._parse_args(args)
 --- modulename: pathlib, funcname: _parse_args
pathlib.py(662):         parts = []
pathlib.py(663):         for a in args:
pathlib.py(664):             if isinstance(a, PurePath):
pathlib.py(667):                 a = os.fspath(a)
pathlib.py(668):                 if isinstance(a, str):
pathlib.py(670):                     parts.append(str(a))
pathlib.py(663):         for a in args:
pathlib.py(676):         return cls._flavour.parse_parts(parts)
 --- modulename: pathlib, funcname: parse_parts
pathlib.py(65):         parsed = []
pathlib.py(66):         sep = self.sep
pathlib.py(67):         altsep = self.altsep
pathlib.py(68):         drv = root = ''
pathlib.py(69):         it = reversed(parts)
pathlib.py(70):         for part in it:
pathlib.py(71):             if not part:
pathlib.py(73):             if altsep:
pathlib.py(75):             drv, root, rel = self.splitroot(part)
 --- modulename: pathlib, funcname: splitroot
pathlib.py(294):         if part and part[0] == sep:
pathlib.py(306):             return '', '', part
pathlib.py(76):             if sep in rel:
pathlib.py(77):                 for x in reversed(rel.split(sep)):
pathlib.py(78):                     if x and x != '.':
pathlib.py(79):                         parsed.append(sys.intern(x))
pathlib.py(77):                 for x in reversed(rel.split(sep)):
pathlib.py(78):                     if x and x != '.':
pathlib.py(79):                         parsed.append(sys.intern(x))
pathlib.py(77):                 for x in reversed(rel.split(sep)):
pathlib.py(83):             if drv or root:
pathlib.py(70):         for part in it:
pathlib.py(97):         if drv or root:
pathlib.py(99):         parsed.reverse()
pathlib.py(100):         return drv, root, parsed
pathlib.py(684):         self._drv = drv
pathlib.py(685):         self._root = root
pathlib.py(686):         self._parts = parts
pathlib.py(687):         if init:
pathlib.py(689):         return self
pathlib.py(1043):         if not self._flavour.is_supported:
pathlib.py(1046):         self._init()
 --- modulename: pathlib, funcname: _init
pathlib.py(1053):         self._closed = False
pathlib.py(1054):         if template is not None:
pathlib.py(1057):             self._accessor = _normal_accessor
pathlib.py(1047):         return self
argparse.py(2438):         return result
argparse.py(2390):             self._check_value(action, value)
 --- modulename: argparse, funcname: _check_value
argparse.py(2442):         if action.choices is not None and value not in action.choices:
argparse.py(2412):         return value
argparse.py(1863):             if argument_values is not action.default:
argparse.py(1864):                 seen_non_default_actions.add(action)
argparse.py(1865):                 for conflict_action in action_conflicts.get(action, []):
argparse.py(1873):             if argument_values is not SUPPRESS:
argparse.py(1874):                 action(self, namespace, argument_values, option_string)
 --- modulename: argparse, funcname: __call__
argparse.py(881):         setattr(namespace, self.dest, values)
argparse.py(1945):             for action, args, option_string in action_tuples:
argparse.py(1947):             return stop
argparse.py(1980):         while start_index <= max_option_string_index:
argparse.py(2009):         stop_index = consume_positionals(start_index)
 --- modulename: argparse, funcname: consume_positionals
argparse.py(1956):             match_partial = self._match_arguments_partial
argparse.py(1957):             selected_pattern = arg_strings_pattern[start_index:]
argparse.py(1958):             arg_counts = match_partial(positionals, selected_pattern)
 --- modulename: argparse, funcname: _match_arguments_partial
argparse.py(2109):         result = []
argparse.py(2110):         for i in range(len(actions), 0, -1):
argparse.py(2120):         return result
argparse.py(1962):             for action, arg_count in zip(positionals, arg_counts):
argparse.py(1969):             positionals[:] = positionals[len(arg_counts):]
argparse.py(1970):             return start_index
argparse.py(2012):         extras.extend(arg_strings[stop_index:])
argparse.py(2016):         required_actions = []
argparse.py(2017):         for action in self._actions:
argparse.py(2018):             if action not in seen_actions:
argparse.py(2019):                 if action.required:
argparse.py(2026):                     if (action.default is not None and
argparse.py(2027):                         isinstance(action.default, str) and
argparse.py(2026):                     if (action.default is not None and
argparse.py(2028):                         hasattr(namespace, action.dest) and
argparse.py(2026):                     if (action.default is not None and
argparse.py(2017):         for action in self._actions:
argparse.py(2018):             if action not in seen_actions:
argparse.py(2017):         for action in self._actions:
argparse.py(2018):             if action not in seen_actions:
argparse.py(2017):         for action in self._actions:
argparse.py(2018):             if action not in seen_actions:
argparse.py(2019):                 if action.required:
argparse.py(2026):                     if (action.default is not None and
argparse.py(2027):                         isinstance(action.default, str) and
argparse.py(2026):                     if (action.default is not None and
argparse.py(2017):         for action in self._actions:
argparse.py(2018):             if action not in seen_actions:
argparse.py(2019):                 if action.required:
argparse.py(2026):                     if (action.default is not None and
argparse.py(2027):                         isinstance(action.default, str) and
argparse.py(2026):                     if (action.default is not None and
argparse.py(2028):                         hasattr(namespace, action.dest) and
argparse.py(2026):                     if (action.default is not None and
argparse.py(2029):                         action.default is getattr(namespace, action.dest)):
argparse.py(2026):                     if (action.default is not None and
argparse.py(2030):                         setattr(namespace, action.dest,
argparse.py(2031):                                 self._get_value(action, action.default))
 --- modulename: argparse, funcname: _get_value
argparse.py(2415):         type_func = self._registry_get('type', action.type, action.type)
 --- modulename: argparse, funcname: _registry_get
argparse.py(1313):         return self._registries[registry_name].get(value, default)
argparse.py(2416):         if not callable(type_func):
argparse.py(2421):         try:
argparse.py(2422):             result = type_func(arg_string)
argparse.py(2438):         return result
argparse.py(2030):                         setattr(namespace, action.dest,
argparse.py(2017):         for action in self._actions:
argparse.py(2033):         if required_actions:
argparse.py(2038):         for group in self._mutually_exclusive_groups:
argparse.py(2053):         return namespace, extras
argparse.py(1801):             if hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR):
argparse.py(1804):             return namespace, args
argparse.py(1769):         if argv:
argparse.py(1772):         return args
__main__.py(54): run(
__main__.py(55):     args.src,
__main__.py(56):     args.dst_dir,
__main__.py(57):     args.seed,
__main__.py(58):     args.file_header
__main__.py(54): run(
 --- modulename: run, funcname: run
run.py(35):     dir_path = Path(os.path.dirname(os.path.realpath(__file__)))
 --- modulename: posixpath, funcname: realpath
posixpath.py(390):     filename = os.fspath(filename)
posixpath.py(391):     path, ok = _joinrealpath(filename[:0], filename, {})
 --- modulename: posixpath, funcname: _joinrealpath
posixpath.py(397):     if isinstance(path, bytes):
posixpath.py(402):         sep = '/'
posixpath.py(403):         curdir = '.'
posixpath.py(404):         pardir = '..'
posixpath.py(406):     if isabs(rest):
 --- modulename: posixpath, funcname: isabs
posixpath.py(62):     s = os.fspath(s)
posixpath.py(63):     sep = _get_sep(s)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(64):     return s.startswith(sep)
posixpath.py(407):         rest = rest[1:]
posixpath.py(408):         path = sep
posixpath.py(410):     while rest:
posixpath.py(411):         name, _, rest = rest.partition(sep)
posixpath.py(412):         if not name or name == curdir:
posixpath.py(415):         if name == pardir:
posixpath.py(424):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(86):                 path += b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
posixpath.py(425):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(166):     try:
posixpath.py(167):         st = os.lstat(path)
posixpath.py(170):     return stat.S_ISLNK(st.st_mode)
posixpath.py(426):             path = newpath
posixpath.py(427):             continue
posixpath.py(410):     while rest:
posixpath.py(411):         name, _, rest = rest.partition(sep)
posixpath.py(412):         if not name or name == curdir:
posixpath.py(415):         if name == pardir:
posixpath.py(424):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
posixpath.py(425):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(166):     try:
posixpath.py(167):         st = os.lstat(path)
posixpath.py(170):     return stat.S_ISLNK(st.st_mode)
posixpath.py(426):             path = newpath
posixpath.py(427):             continue
posixpath.py(410):     while rest:
posixpath.py(411):         name, _, rest = rest.partition(sep)
posixpath.py(412):         if not name or name == curdir:
posixpath.py(415):         if name == pardir:
posixpath.py(424):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
posixpath.py(425):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(166):     try:
posixpath.py(167):         st = os.lstat(path)
posixpath.py(170):     return stat.S_ISLNK(st.st_mode)
posixpath.py(426):             path = newpath
posixpath.py(427):             continue
posixpath.py(410):     while rest:
posixpath.py(411):         name, _, rest = rest.partition(sep)
posixpath.py(412):         if not name or name == curdir:
posixpath.py(415):         if name == pardir:
posixpath.py(424):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
posixpath.py(425):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(166):     try:
posixpath.py(167):         st = os.lstat(path)
posixpath.py(170):     return stat.S_ISLNK(st.st_mode)
posixpath.py(426):             path = newpath
posixpath.py(427):             continue
posixpath.py(410):     while rest:
posixpath.py(411):         name, _, rest = rest.partition(sep)
posixpath.py(412):         if not name or name == curdir:
posixpath.py(415):         if name == pardir:
posixpath.py(424):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
posixpath.py(425):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(166):     try:
posixpath.py(167):         st = os.lstat(path)
posixpath.py(170):     return stat.S_ISLNK(st.st_mode)
posixpath.py(426):             path = newpath
posixpath.py(427):             continue
posixpath.py(410):     while rest:
posixpath.py(411):         name, _, rest = rest.partition(sep)
posixpath.py(412):         if not name or name == curdir:
posixpath.py(415):         if name == pardir:
posixpath.py(424):         newpath = join(path, name)
 --- modulename: posixpath, funcname: join
posixpath.py(76):     a = os.fspath(a)
posixpath.py(77):     sep = _get_sep(a)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(78):     path = a
posixpath.py(79):     try:
posixpath.py(80):         if not p:
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(83):             if b.startswith(sep):
posixpath.py(85):             elif not path or path.endswith(sep):
posixpath.py(88):                 path += sep + b
posixpath.py(82):         for b in map(os.fspath, p):
posixpath.py(92):     return path
posixpath.py(425):         if not islink(newpath):
 --- modulename: posixpath, funcname: islink
posixpath.py(166):     try:
posixpath.py(167):         st = os.lstat(path)
posixpath.py(170):     return stat.S_ISLNK(st.st_mode)
posixpath.py(426):             path = newpath
posixpath.py(427):             continue
posixpath.py(410):     while rest:
posixpath.py(444):     return path, True
posixpath.py(392):     return abspath(path)
 --- modulename: posixpath, funcname: abspath
posixpath.py(374):     path = os.fspath(path)
posixpath.py(375):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(62):     s = os.fspath(s)
posixpath.py(63):     sep = _get_sep(s)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(64):     return s.startswith(sep)
posixpath.py(381):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(336):     path = os.fspath(path)
posixpath.py(337):     if isinstance(path, bytes):
posixpath.py(343):         sep = '/'
posixpath.py(344):         empty = ''
posixpath.py(345):         dot = '.'
posixpath.py(346):         dotdot = '..'
posixpath.py(347):     if path == empty:
posixpath.py(349):     initial_slashes = path.startswith(sep)
posixpath.py(352):     if (initial_slashes and
posixpath.py(353):         path.startswith(sep*2) and not path.startswith(sep*3)):
posixpath.py(352):     if (initial_slashes and
posixpath.py(355):     comps = path.split(sep)
posixpath.py(356):     new_comps = []
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(359):             continue
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(360):         if (comp != dotdot or (not initial_slashes and not new_comps) or
posixpath.py(362):             new_comps.append(comp)
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(360):         if (comp != dotdot or (not initial_slashes and not new_comps) or
posixpath.py(362):             new_comps.append(comp)
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(360):         if (comp != dotdot or (not initial_slashes and not new_comps) or
posixpath.py(362):             new_comps.append(comp)
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(360):         if (comp != dotdot or (not initial_slashes and not new_comps) or
posixpath.py(362):             new_comps.append(comp)
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(360):         if (comp != dotdot or (not initial_slashes and not new_comps) or
posixpath.py(362):             new_comps.append(comp)
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(360):         if (comp != dotdot or (not initial_slashes and not new_comps) or
posixpath.py(362):             new_comps.append(comp)
posixpath.py(357):     for comp in comps:
posixpath.py(365):     comps = new_comps
posixpath.py(366):     path = sep.join(comps)
posixpath.py(367):     if initial_slashes:
posixpath.py(368):         path = sep*initial_slashes + path
posixpath.py(369):     return path or dot
 --- modulename: posixpath, funcname: dirname
posixpath.py(152):     p = os.fspath(p)
posixpath.py(153):     sep = _get_sep(p)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(154):     i = p.rfind(sep) + 1
posixpath.py(155):     head = p[:i]
posixpath.py(156):     if head and head != sep*len(head):
posixpath.py(157):         head = head.rstrip(sep)
posixpath.py(158):     return head
 --- modulename: pathlib, funcname: __new__
pathlib.py(1040):         if cls is Path:
pathlib.py(1041):             cls = WindowsPath if os.name == 'nt' else PosixPath
pathlib.py(1042):         self = cls._from_parts(args, init=False)
 --- modulename: pathlib, funcname: _from_parts
pathlib.py(682):         self = object.__new__(cls)
pathlib.py(683):         drv, root, parts = self._parse_args(args)
 --- modulename: pathlib, funcname: _parse_args
pathlib.py(662):         parts = []
pathlib.py(663):         for a in args:
pathlib.py(664):             if isinstance(a, PurePath):
pathlib.py(667):                 a = os.fspath(a)
pathlib.py(668):                 if isinstance(a, str):
pathlib.py(670):                     parts.append(str(a))
pathlib.py(663):         for a in args:
pathlib.py(676):         return cls._flavour.parse_parts(parts)
 --- modulename: pathlib, funcname: parse_parts
pathlib.py(65):         parsed = []
pathlib.py(66):         sep = self.sep
pathlib.py(67):         altsep = self.altsep
pathlib.py(68):         drv = root = ''
pathlib.py(69):         it = reversed(parts)
pathlib.py(70):         for part in it:
pathlib.py(71):             if not part:
pathlib.py(73):             if altsep:
pathlib.py(75):             drv, root, rel = self.splitroot(part)
 --- modulename: pathlib, funcname: splitroot
pathlib.py(294):         if part and part[0] == sep:
pathlib.py(295):             stripped_part = part.lstrip(sep)
pathlib.py(301):             if len(part) - len(stripped_part) == 2:
pathlib.py(304):                 return '', sep, stripped_part
pathlib.py(76):             if sep in rel:
pathlib.py(77):                 for x in reversed(rel.split(sep)):
pathlib.py(78):                     if x and x != '.':
pathlib.py(79):                         parsed.append(sys.intern(x))
pathlib.py(77):                 for x in reversed(rel.split(sep)):
pathlib.py(78):                     if x and x != '.':
pathlib.py(79):                         parsed.append(sys.intern(x))
pathlib.py(77):                 for x in reversed(rel.split(sep)):
pathlib.py(78):                     if x and x != '.':
pathlib.py(79):                         parsed.append(sys.intern(x))
pathlib.py(77):                 for x in reversed(rel.split(sep)):
pathlib.py(78):                     if x and x != '.':
pathlib.py(79):                         parsed.append(sys.intern(x))
pathlib.py(77):                 for x in reversed(rel.split(sep)):
pathlib.py(78):                     if x and x != '.':
pathlib.py(79):                         parsed.append(sys.intern(x))
pathlib.py(77):                 for x in reversed(rel.split(sep)):
pathlib.py(83):             if drv or root:
pathlib.py(84):                 if not drv:
pathlib.py(88):                     for part in it:
pathlib.py(96):                 break
pathlib.py(97):         if drv or root:
pathlib.py(98):             parsed.append(drv + root)
pathlib.py(99):         parsed.reverse()
pathlib.py(100):         return drv, root, parsed
pathlib.py(684):         self._drv = drv
pathlib.py(685):         self._root = root
pathlib.py(686):         self._parts = parts
pathlib.py(687):         if init:
pathlib.py(689):         return self
pathlib.py(1043):         if not self._flavour.is_supported:
pathlib.py(1046):         self._init()
 --- modulename: pathlib, funcname: _init
pathlib.py(1053):         self._closed = False
pathlib.py(1054):         if template is not None:
pathlib.py(1057):             self._accessor = _normal_accessor
pathlib.py(1047):         return self
run.py(36):     log_path = dir_path / "pa1.log"
 --- modulename: pathlib, funcname: __truediv__
pathlib.py(934):         try:
pathlib.py(935):             return self._make_child((key,))
 --- modulename: pathlib, funcname: _make_child
pathlib.py(713):         drv, root, parts = self._parse_args(args)
 --- modulename: pathlib, funcname: _parse_args
pathlib.py(662):         parts = []
pathlib.py(663):         for a in args:
pathlib.py(664):             if isinstance(a, PurePath):
pathlib.py(667):                 a = os.fspath(a)
pathlib.py(668):                 if isinstance(a, str):
pathlib.py(670):                     parts.append(str(a))
pathlib.py(663):         for a in args:
pathlib.py(676):         return cls._flavour.parse_parts(parts)
 --- modulename: pathlib, funcname: parse_parts
pathlib.py(65):         parsed = []
pathlib.py(66):         sep = self.sep
pathlib.py(67):         altsep = self.altsep
pathlib.py(68):         drv = root = ''
pathlib.py(69):         it = reversed(parts)
pathlib.py(70):         for part in it:
pathlib.py(71):             if not part:
pathlib.py(73):             if altsep:
pathlib.py(75):             drv, root, rel = self.splitroot(part)
 --- modulename: pathlib, funcname: splitroot
pathlib.py(294):         if part and part[0] == sep:
pathlib.py(306):             return '', '', part
pathlib.py(76):             if sep in rel:
pathlib.py(81):                 if rel and rel != '.':
pathlib.py(82):                     parsed.append(sys.intern(rel))
pathlib.py(83):             if drv or root:
pathlib.py(70):         for part in it:
pathlib.py(97):         if drv or root:
pathlib.py(99):         parsed.reverse()
pathlib.py(100):         return drv, root, parsed
pathlib.py(714):         drv, root, parts = self._flavour.join_parsed_parts(
pathlib.py(715):             self._drv, self._root, self._parts, drv, root, parts)
pathlib.py(714):         drv, root, parts = self._flavour.join_parsed_parts(
 --- modulename: pathlib, funcname: join_parsed_parts
pathlib.py(107):         if root2:
pathlib.py(110):         elif drv2:
pathlib.py(116):             return drv, root, parts + parts2
pathlib.py(716):         return self._from_parsed_parts(drv, root, parts)
 --- modulename: pathlib, funcname: _from_parsed_parts
pathlib.py(693):         self = object.__new__(cls)
pathlib.py(694):         self._drv = drv
pathlib.py(695):         self._root = root
pathlib.py(696):         self._parts = parts
pathlib.py(697):         if init:
pathlib.py(698):             self._init()
 --- modulename: pathlib, funcname: _init
pathlib.py(1053):         self._closed = False
pathlib.py(1054):         if template is not None:
pathlib.py(1057):             self._accessor = _normal_accessor
pathlib.py(699):         return self
run.py(37):     log_format = "%(asctime)s - %(levelname)s - %(message)s"
run.py(38):     logging.basicConfig(filename=log_path, level=logging.DEBUG, format=log_format)
 --- modulename: __init__, funcname: basicConfig
__init__.py(1967):     _acquireLock()
 --- modulename: __init__, funcname: _acquireLock
__init__.py(224):     if _lock:
__init__.py(225):         _lock.acquire()
__init__.py(1968):     try:
__init__.py(1969):         force = kwargs.pop('force', False)
__init__.py(1970):         if force:
__init__.py(1974):         if len(root.handlers) == 0:
__init__.py(1975):             handlers = kwargs.pop("handlers", None)
__init__.py(1976):             if handlers is None:
__init__.py(1977):                 if "stream" in kwargs and "filename" in kwargs:
__init__.py(1984):             if handlers is None:
__init__.py(1985):                 filename = kwargs.pop("filename", None)
__init__.py(1986):                 mode = kwargs.pop("filemode", 'a')
__init__.py(1987):                 if filename:
__init__.py(1988):                     h = FileHandler(filename, mode)
 --- modulename: __init__, funcname: __init__
__init__.py(1134):         filename = os.fspath(filename)
 --- modulename: pathlib, funcname: __fspath__
pathlib.py(729):         return str(self)
 --- modulename: pathlib, funcname: __str__
pathlib.py(721):         try:
pathlib.py(722):             return self._str
pathlib.py(723):         except AttributeError:
pathlib.py(724):             self._str = self._format_parsed_parts(self._drv, self._root,
pathlib.py(725):                                                   self._parts) or '.'
pathlib.py(724):             self._str = self._format_parsed_parts(self._drv, self._root,
 --- modulename: pathlib, funcname: _format_parsed_parts
pathlib.py(703):         if drv or root:
pathlib.py(704):             return drv + root + cls._flavour.join(parts[1:])
pathlib.py(724):             self._str = self._format_parsed_parts(self._drv, self._root,
pathlib.py(726):             return self._str
__init__.py(1137):         self.baseFilename = os.path.abspath(filename)
 --- modulename: posixpath, funcname: abspath
posixpath.py(374):     path = os.fspath(path)
posixpath.py(375):     if not isabs(path):
 --- modulename: posixpath, funcname: isabs
posixpath.py(62):     s = os.fspath(s)
posixpath.py(63):     sep = _get_sep(s)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(64):     return s.startswith(sep)
posixpath.py(381):     return normpath(path)
 --- modulename: posixpath, funcname: normpath
posixpath.py(336):     path = os.fspath(path)
posixpath.py(337):     if isinstance(path, bytes):
posixpath.py(343):         sep = '/'
posixpath.py(344):         empty = ''
posixpath.py(345):         dot = '.'
posixpath.py(346):         dotdot = '..'
posixpath.py(347):     if path == empty:
posixpath.py(349):     initial_slashes = path.startswith(sep)
posixpath.py(352):     if (initial_slashes and
posixpath.py(353):         path.startswith(sep*2) and not path.startswith(sep*3)):
posixpath.py(352):     if (initial_slashes and
posixpath.py(355):     comps = path.split(sep)
posixpath.py(356):     new_comps = []
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(359):             continue
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(360):         if (comp != dotdot or (not initial_slashes and not new_comps) or
posixpath.py(362):             new_comps.append(comp)
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(360):         if (comp != dotdot or (not initial_slashes and not new_comps) or
posixpath.py(362):             new_comps.append(comp)
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(360):         if (comp != dotdot or (not initial_slashes and not new_comps) or
posixpath.py(362):             new_comps.append(comp)
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(360):         if (comp != dotdot or (not initial_slashes and not new_comps) or
posixpath.py(362):             new_comps.append(comp)
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(360):         if (comp != dotdot or (not initial_slashes and not new_comps) or
posixpath.py(362):             new_comps.append(comp)
posixpath.py(357):     for comp in comps:
posixpath.py(358):         if comp in (empty, dot):
posixpath.py(360):         if (comp != dotdot or (not initial_slashes and not new_comps) or
posixpath.py(362):             new_comps.append(comp)
posixpath.py(357):     for comp in comps:
posixpath.py(365):     comps = new_comps
posixpath.py(366):     path = sep.join(comps)
posixpath.py(367):     if initial_slashes:
posixpath.py(368):         path = sep*initial_slashes + path
posixpath.py(369):     return path or dot
__init__.py(1138):         self.mode = mode
__init__.py(1139):         self.encoding = encoding
__init__.py(1140):         self.delay = delay
__init__.py(1141):         if delay:
__init__.py(1147):             StreamHandler.__init__(self, self._open())
 --- modulename: __init__, funcname: _open
__init__.py(1176):         return open(self.baseFilename, self.mode, encoding=self.encoding)
 --- modulename: _bootlocale, funcname: getpreferredencoding
_bootlocale.py(34):             assert not do_setlocale
_bootlocale.py(35):             if sys.flags.utf8_mode:
_bootlocale.py(37):             result = _locale.nl_langinfo(_locale.CODESET)
_bootlocale.py(38):             if not result and sys.platform == 'darwin':
_bootlocale.py(46):             return result
 --- modulename: codecs, funcname: __init__
codecs.py(194):         self.errors = errors
codecs.py(195):         self.buffer = ""
 --- modulename: codecs, funcname: setstate
codecs.py(215):         """
 --- modulename: __init__, funcname: __init__
__init__.py(1057):         Handler.__init__(self)
 --- modulename: __init__, funcname: __init__
__init__.py(867):         Filterer.__init__(self)
 --- modulename: __init__, funcname: __init__
__init__.py(780):         self.filters = []
__init__.py(868):         self._name = None
__init__.py(869):         self.level = _checkLevel(level)
 --- modulename: __init__, funcname: _checkLevel
__init__.py(194):     if isinstance(level, int):
__init__.py(195):         rv = level
__init__.py(202):     return rv
__init__.py(870):         self.formatter = None
__init__.py(872):         _addHandlerRef(self)
 --- modulename: __init__, funcname: _addHandlerRef
__init__.py(847):     _acquireLock()
 --- modulename: __init__, funcname: _acquireLock
__init__.py(224):     if _lock:
__init__.py(225):         _lock.acquire()
__init__.py(848):     try:
__init__.py(849):         _handlerList.append(weakref.ref(handler, _removeHandlerRef))
__init__.py(851):         _releaseLock()
 --- modulename: __init__, funcname: _releaseLock
__init__.py(231):     if _lock:
__init__.py(232):         _lock.release()
__init__.py(873):         self.createLock()
 --- modulename: __init__, funcname: createLock
__init__.py(895):         self.lock = threading.RLock()
 --- modulename: threading, funcname: RLock
threading.py(90):     if _CRLock is None:
threading.py(92):     return _CRLock(*args, **kwargs)
__init__.py(896):         _register_at_fork_reinit_lock(self)
 --- modulename: __init__, funcname: _register_at_fork_reinit_lock
__init__.py(249):         _acquireLock()
 --- modulename: __init__, funcname: _acquireLock
__init__.py(224):     if _lock:
__init__.py(225):         _lock.acquire()
__init__.py(250):         try:
__init__.py(251):             _at_fork_reinit_lock_weakset.add(instance)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
__init__.py(253):             _releaseLock()
 --- modulename: __init__, funcname: _releaseLock
__init__.py(231):     if _lock:
__init__.py(232):         _lock.release()
__init__.py(1058):         if stream is None:
__init__.py(1060):         self.stream = stream
__init__.py(1992):                 handlers = [h]
__init__.py(1993):             dfs = kwargs.pop("datefmt", None)
__init__.py(1994):             style = kwargs.pop("style", '%')
__init__.py(1995):             if style not in _STYLES:
__init__.py(1998):             fs = kwargs.pop("format", _STYLES[style][1])
__init__.py(1999):             fmt = Formatter(fs, dfs, style)
 --- modulename: __init__, funcname: __init__
__init__.py(575):         if style not in _STYLES:
__init__.py(578):         self._style = _STYLES[style][0](fmt)
 --- modulename: __init__, funcname: __init__
__init__.py(425):         self._fmt = fmt or self.default_format
__init__.py(579):         if validate:
__init__.py(580):             self._style.validate()
 --- modulename: __init__, funcname: validate
__init__.py(432):         if not self.validation_pattern.search(self._fmt):
__init__.py(582):         self._fmt = self._style._fmt
__init__.py(583):         self.datefmt = datefmt
__init__.py(2000):             for h in handlers:
__init__.py(2001):                 if h.formatter is None:
__init__.py(2002):                     h.setFormatter(fmt)
 --- modulename: __init__, funcname: setFormatter
__init__.py(963):         self.formatter = fmt
__init__.py(2003):                 root.addHandler(h)
 --- modulename: __init__, funcname: addHandler
__init__.py(1605):         _acquireLock()
 --- modulename: __init__, funcname: _acquireLock
__init__.py(224):     if _lock:
__init__.py(225):         _lock.acquire()
__init__.py(1606):         try:
__init__.py(1607):             if not (hdlr in self.handlers):
__init__.py(1608):                 self.handlers.append(hdlr)
__init__.py(1610):             _releaseLock()
 --- modulename: __init__, funcname: _releaseLock
__init__.py(231):     if _lock:
__init__.py(232):         _lock.release()
__init__.py(2000):             for h in handlers:
__init__.py(2004):             level = kwargs.pop("level", None)
__init__.py(2005):             if level is not None:
__init__.py(2006):                 root.setLevel(level)
 --- modulename: __init__, funcname: setLevel
__init__.py(1421):         self.level = _checkLevel(level)
 --- modulename: __init__, funcname: _checkLevel
__init__.py(194):     if isinstance(level, int):
__init__.py(195):         rv = level
__init__.py(202):     return rv
__init__.py(1422):         self.manager._clear_cache()
 --- modulename: __init__, funcname: _clear_cache
__init__.py(1378):         _acquireLock()
 --- modulename: __init__, funcname: _acquireLock
__init__.py(224):     if _lock:
__init__.py(225):         _lock.acquire()
__init__.py(1379):         for logger in self.loggerDict.values():
__init__.py(1382):         self.root._cache.clear()
__init__.py(1383):         _releaseLock()
 --- modulename: __init__, funcname: _releaseLock
__init__.py(231):     if _lock:
__init__.py(232):         _lock.release()
__init__.py(2007):             if kwargs:
__init__.py(2011):         _releaseLock()
 --- modulename: __init__, funcname: _releaseLock
__init__.py(231):     if _lock:
__init__.py(232):         _lock.release()
run.py(40):     logging.debug(f"Begin run: src={src.name}, dst_dir={dst_dir.name}, seed={seed}")
 --- modulename: pathlib, funcname: name
pathlib.py(807):         parts = self._parts
pathlib.py(808):         if len(parts) == (1 if (self._drv or self._root) else 0):
pathlib.py(810):         return parts[-1]
 --- modulename: pathlib, funcname: name
pathlib.py(807):         parts = self._parts
pathlib.py(808):         if len(parts) == (1 if (self._drv or self._root) else 0):
pathlib.py(810):         return parts[-1]
 --- modulename: __init__, funcname: debug
__init__.py(2090):     if len(root.handlers) == 0:
__init__.py(2092):     root.debug(msg, *args, **kwargs)
 --- modulename: __init__, funcname: debug
__init__.py(1433):         if self.isEnabledFor(DEBUG):
 --- modulename: __init__, funcname: isEnabledFor
__init__.py(1693):         if self.disabled:
__init__.py(1696):         try:
__init__.py(1697):             return self._cache[level]
__init__.py(1698):         except KeyError:
__init__.py(1699):             _acquireLock()
 --- modulename: __init__, funcname: _acquireLock
__init__.py(224):     if _lock:
__init__.py(225):         _lock.acquire()
__init__.py(1700):             try:
__init__.py(1701):                 if self.manager.disable >= level:
 --- modulename: __init__, funcname: disable
__init__.py(1278):         return self._disable
__init__.py(1705):                         level >= self.getEffectiveLevel()
 --- modulename: __init__, funcname: getEffectiveLevel
__init__.py(1682):         logger = self
__init__.py(1683):         while logger:
__init__.py(1684):             if logger.level:
__init__.py(1685):                 return logger.level
__init__.py(1704):                     is_enabled = self._cache[level] = (
__init__.py(1708):                 _releaseLock()
 --- modulename: __init__, funcname: _releaseLock
__init__.py(231):     if _lock:
__init__.py(232):         _lock.release()
__init__.py(1709):             return is_enabled
__init__.py(1434):             self._log(DEBUG, msg, args, **kwargs)
 --- modulename: __init__, funcname: _log
__init__.py(1571):         sinfo = None
__init__.py(1572):         if _srcfile:
__init__.py(1576):             try:
__init__.py(1577):                 fn, lno, func, sinfo = self.findCaller(stack_info, stacklevel)
 --- modulename: __init__, funcname: findCaller
__init__.py(1519):         f = currentframe()
 --- modulename: __init__, funcname: <lambda>
__init__.py(160):     currentframe = lambda: sys._getframe(3)
__init__.py(1522):         if f is not None:
__init__.py(1523):             f = f.f_back
__init__.py(1524):         orig_f = f
__init__.py(1525):         while f and stacklevel > 1:
__init__.py(1528):         if not f:
__init__.py(1530):         rv = "(unknown file)", 0, "(unknown function)", None
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1535):                 f = f.f_back
__init__.py(1536):                 continue
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1537):             sinfo = None
__init__.py(1538):             if stack_info:
__init__.py(1546):             rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)
__init__.py(1547):             break
__init__.py(1548):         return rv
__init__.py(1582):         if exc_info:
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
__init__.py(1588):                                  exc_info, func, extra, sinfo)
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
 --- modulename: __init__, funcname: makeRecord
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
__init__.py(1557):                              sinfo)
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
 --- modulename: __init__, funcname: __init__
__init__.py(293):         ct = time.time()
__init__.py(294):         self.name = name
__init__.py(295):         self.msg = msg
__init__.py(314):         if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)
__init__.py(317):         self.args = args
__init__.py(318):         self.levelname = getLevelName(level)
 --- modulename: __init__, funcname: getLevelName
__init__.py(138):     result = _levelToName.get(level)
__init__.py(139):     if result is not None:
__init__.py(140):         return result
__init__.py(319):         self.levelno = level
__init__.py(320):         self.pathname = pathname
__init__.py(321):         try:
__init__.py(322):             self.filename = os.path.basename(pathname)
 --- modulename: posixpath, funcname: basename
posixpath.py(142):     p = os.fspath(p)
posixpath.py(143):     sep = _get_sep(p)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(144):     i = p.rfind(sep) + 1
posixpath.py(145):     return p[i:]
__init__.py(323):             self.module = os.path.splitext(self.filename)[0]
 --- modulename: posixpath, funcname: splitext
posixpath.py(118):     p = os.fspath(p)
posixpath.py(119):     if isinstance(p, bytes):
posixpath.py(123):         sep = '/'
posixpath.py(124):         extsep = '.'
posixpath.py(125):     return genericpath._splitext(p, sep, None, extsep)
 --- modulename: genericpath, funcname: _splitext
genericpath.py(128):     sepIndex = p.rfind(sep)
genericpath.py(129):     if altsep:
genericpath.py(133):     dotIndex = p.rfind(extsep)
genericpath.py(134):     if dotIndex > sepIndex:
genericpath.py(136):         filenameIndex = sepIndex + 1
genericpath.py(137):         while filenameIndex < dotIndex:
genericpath.py(138):             if p[filenameIndex:filenameIndex+1] != extsep:
genericpath.py(139):                 return p[:dotIndex], p[dotIndex:]
__init__.py(327):         self.exc_info = exc_info
__init__.py(328):         self.exc_text = None      # used to cache the traceback text
__init__.py(329):         self.stack_info = sinfo
__init__.py(330):         self.lineno = lineno
__init__.py(331):         self.funcName = func
__init__.py(332):         self.created = ct
__init__.py(333):         self.msecs = (ct - int(ct)) * 1000
__init__.py(334):         self.relativeCreated = (self.created - _startTime) * 1000
__init__.py(335):         if logThreads:
__init__.py(336):             self.thread = threading.get_ident()
__init__.py(337):             self.threadName = threading.current_thread().name
 --- modulename: threading, funcname: current_thread
threading.py(1313):     try:
threading.py(1314):         return _active[get_ident()]
 --- modulename: threading, funcname: name
threading.py(1039):         assert self._initialized, "Thread.__init__() not called"
threading.py(1040):         return self._name
__init__.py(341):         if not logMultiprocessing: # pragma: no cover
__init__.py(344):             self.processName = 'MainProcess'
__init__.py(345):             mp = sys.modules.get('multiprocessing')
__init__.py(346):             if mp is not None:
__init__.py(355):         if logProcesses and hasattr(os, 'getpid'):
__init__.py(356):             self.process = os.getpid()
__init__.py(1558):         if extra is not None:
__init__.py(1563):         return rv
__init__.py(1589):         self.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(1598):         if (not self.disabled) and self.filter(record):
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(1599):             self.callHandlers(record)
 --- modulename: __init__, funcname: callHandlers
__init__.py(1655):         c = self
__init__.py(1656):         found = 0
__init__.py(1657):         while c:
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1659):                 found = found + 1
__init__.py(1660):                 if record.levelno >= hdlr.level:
__init__.py(1661):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(950):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(951):         if rv:
__init__.py(952):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(953):             try:
__init__.py(954):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1185):         if self.stream is None:
__init__.py(1187):         StreamHandler.emit(self, record)
 --- modulename: __init__, funcname: emit
__init__.py(1084):         try:
__init__.py(1085):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(925):         if self.formatter:
__init__.py(926):             fmt = self.formatter
__init__.py(929):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(668):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(371):         msg = str(self.msg)
__init__.py(372):         if self.args:
__init__.py(374):         return msg
__init__.py(669):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(637):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(428):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(670):             record.asctime = self.formatTime(record, self.datefmt)
 --- modulename: __init__, funcname: formatTime
__init__.py(606):         ct = self.converter(record.created)
__init__.py(607):         if datefmt:
__init__.py(610):             t = time.strftime(self.default_time_format, ct)
__init__.py(611):             s = self.default_msec_format % (t, record.msecs)
__init__.py(612):         return s
__init__.py(671):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(640):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(439):         try:
__init__.py(440):             return self._format(record)
 --- modulename: __init__, funcname: _format
__init__.py(436):         return self._fmt % record.__dict__
__init__.py(672):         if record.exc_info:
__init__.py(677):         if record.exc_text:
__init__.py(681):         if record.stack_info:
__init__.py(685):         return s
__init__.py(1086):             stream = self.stream
__init__.py(1088):             stream.write(msg + self.terminator)
__init__.py(1089):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1066):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(1067):         try:
__init__.py(1068):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1069):                 self.stream.flush()
__init__.py(1071):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(956):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(957):         return rv
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1662):             if not c.propagate:
__init__.py(1665):                 c = c.parent
__init__.py(1657):         while c:
__init__.py(1666):         if (found == 0):
run.py(42):     logging.debug("Read data and check, among other things, that m <= n choose 2")
 --- modulename: __init__, funcname: debug
__init__.py(2090):     if len(root.handlers) == 0:
__init__.py(2092):     root.debug(msg, *args, **kwargs)
 --- modulename: __init__, funcname: debug
__init__.py(1433):         if self.isEnabledFor(DEBUG):
 --- modulename: __init__, funcname: isEnabledFor
__init__.py(1693):         if self.disabled:
__init__.py(1696):         try:
__init__.py(1697):             return self._cache[level]
__init__.py(1434):             self._log(DEBUG, msg, args, **kwargs)
 --- modulename: __init__, funcname: _log
__init__.py(1571):         sinfo = None
__init__.py(1572):         if _srcfile:
__init__.py(1576):             try:
__init__.py(1577):                 fn, lno, func, sinfo = self.findCaller(stack_info, stacklevel)
 --- modulename: __init__, funcname: findCaller
__init__.py(1519):         f = currentframe()
 --- modulename: __init__, funcname: <lambda>
__init__.py(160):     currentframe = lambda: sys._getframe(3)
__init__.py(1522):         if f is not None:
__init__.py(1523):             f = f.f_back
__init__.py(1524):         orig_f = f
__init__.py(1525):         while f and stacklevel > 1:
__init__.py(1528):         if not f:
__init__.py(1530):         rv = "(unknown file)", 0, "(unknown function)", None
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1535):                 f = f.f_back
__init__.py(1536):                 continue
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1537):             sinfo = None
__init__.py(1538):             if stack_info:
__init__.py(1546):             rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)
__init__.py(1547):             break
__init__.py(1548):         return rv
__init__.py(1582):         if exc_info:
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
__init__.py(1588):                                  exc_info, func, extra, sinfo)
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
 --- modulename: __init__, funcname: makeRecord
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
__init__.py(1557):                              sinfo)
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
 --- modulename: __init__, funcname: __init__
__init__.py(293):         ct = time.time()
__init__.py(294):         self.name = name
__init__.py(295):         self.msg = msg
__init__.py(314):         if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)
__init__.py(317):         self.args = args
__init__.py(318):         self.levelname = getLevelName(level)
 --- modulename: __init__, funcname: getLevelName
__init__.py(138):     result = _levelToName.get(level)
__init__.py(139):     if result is not None:
__init__.py(140):         return result
__init__.py(319):         self.levelno = level
__init__.py(320):         self.pathname = pathname
__init__.py(321):         try:
__init__.py(322):             self.filename = os.path.basename(pathname)
 --- modulename: posixpath, funcname: basename
posixpath.py(142):     p = os.fspath(p)
posixpath.py(143):     sep = _get_sep(p)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(144):     i = p.rfind(sep) + 1
posixpath.py(145):     return p[i:]
__init__.py(323):             self.module = os.path.splitext(self.filename)[0]
 --- modulename: posixpath, funcname: splitext
posixpath.py(118):     p = os.fspath(p)
posixpath.py(119):     if isinstance(p, bytes):
posixpath.py(123):         sep = '/'
posixpath.py(124):         extsep = '.'
posixpath.py(125):     return genericpath._splitext(p, sep, None, extsep)
 --- modulename: genericpath, funcname: _splitext
genericpath.py(128):     sepIndex = p.rfind(sep)
genericpath.py(129):     if altsep:
genericpath.py(133):     dotIndex = p.rfind(extsep)
genericpath.py(134):     if dotIndex > sepIndex:
genericpath.py(136):         filenameIndex = sepIndex + 1
genericpath.py(137):         while filenameIndex < dotIndex:
genericpath.py(138):             if p[filenameIndex:filenameIndex+1] != extsep:
genericpath.py(139):                 return p[:dotIndex], p[dotIndex:]
__init__.py(327):         self.exc_info = exc_info
__init__.py(328):         self.exc_text = None      # used to cache the traceback text
__init__.py(329):         self.stack_info = sinfo
__init__.py(330):         self.lineno = lineno
__init__.py(331):         self.funcName = func
__init__.py(332):         self.created = ct
__init__.py(333):         self.msecs = (ct - int(ct)) * 1000
__init__.py(334):         self.relativeCreated = (self.created - _startTime) * 1000
__init__.py(335):         if logThreads:
__init__.py(336):             self.thread = threading.get_ident()
__init__.py(337):             self.threadName = threading.current_thread().name
 --- modulename: threading, funcname: current_thread
threading.py(1313):     try:
threading.py(1314):         return _active[get_ident()]
 --- modulename: threading, funcname: name
threading.py(1039):         assert self._initialized, "Thread.__init__() not called"
threading.py(1040):         return self._name
__init__.py(341):         if not logMultiprocessing: # pragma: no cover
__init__.py(344):             self.processName = 'MainProcess'
__init__.py(345):             mp = sys.modules.get('multiprocessing')
__init__.py(346):             if mp is not None:
__init__.py(355):         if logProcesses and hasattr(os, 'getpid'):
__init__.py(356):             self.process = os.getpid()
__init__.py(1558):         if extra is not None:
__init__.py(1563):         return rv
__init__.py(1589):         self.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(1598):         if (not self.disabled) and self.filter(record):
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(1599):             self.callHandlers(record)
 --- modulename: __init__, funcname: callHandlers
__init__.py(1655):         c = self
__init__.py(1656):         found = 0
__init__.py(1657):         while c:
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1659):                 found = found + 1
__init__.py(1660):                 if record.levelno >= hdlr.level:
__init__.py(1661):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(950):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(951):         if rv:
__init__.py(952):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(953):             try:
__init__.py(954):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1185):         if self.stream is None:
__init__.py(1187):         StreamHandler.emit(self, record)
 --- modulename: __init__, funcname: emit
__init__.py(1084):         try:
__init__.py(1085):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(925):         if self.formatter:
__init__.py(926):             fmt = self.formatter
__init__.py(929):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(668):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(371):         msg = str(self.msg)
__init__.py(372):         if self.args:
__init__.py(374):         return msg
__init__.py(669):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(637):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(428):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(670):             record.asctime = self.formatTime(record, self.datefmt)
 --- modulename: __init__, funcname: formatTime
__init__.py(606):         ct = self.converter(record.created)
__init__.py(607):         if datefmt:
__init__.py(610):             t = time.strftime(self.default_time_format, ct)
__init__.py(611):             s = self.default_msec_format % (t, record.msecs)
__init__.py(612):         return s
__init__.py(671):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(640):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(439):         try:
__init__.py(440):             return self._format(record)
 --- modulename: __init__, funcname: _format
__init__.py(436):         return self._fmt % record.__dict__
__init__.py(672):         if record.exc_info:
__init__.py(677):         if record.exc_text:
__init__.py(681):         if record.stack_info:
__init__.py(685):         return s
__init__.py(1086):             stream = self.stream
__init__.py(1088):             stream.write(msg + self.terminator)
__init__.py(1089):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1066):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(1067):         try:
__init__.py(1068):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1069):                 self.stream.flush()
__init__.py(1071):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(956):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(957):         return rv
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1662):             if not c.propagate:
__init__.py(1665):                 c = c.parent
__init__.py(1657):         while c:
__init__.py(1666):         if (found == 0):
run.py(43):     input_params: List[List[Union[int, float]]] = read_input_params(src)
 --- modulename: file_io, funcname: read_input_params
file_io.py(27):     in_file = Path(in_file)
 --- modulename: pathlib, funcname: __new__
pathlib.py(1040):         if cls is Path:
pathlib.py(1041):             cls = WindowsPath if os.name == 'nt' else PosixPath
pathlib.py(1042):         self = cls._from_parts(args, init=False)
 --- modulename: pathlib, funcname: _from_parts
pathlib.py(682):         self = object.__new__(cls)
pathlib.py(683):         drv, root, parts = self._parse_args(args)
 --- modulename: pathlib, funcname: _parse_args
pathlib.py(662):         parts = []
pathlib.py(663):         for a in args:
pathlib.py(664):             if isinstance(a, PurePath):
pathlib.py(665):                 parts += a._parts
pathlib.py(663):         for a in args:
pathlib.py(676):         return cls._flavour.parse_parts(parts)
 --- modulename: pathlib, funcname: parse_parts
pathlib.py(65):         parsed = []
pathlib.py(66):         sep = self.sep
pathlib.py(67):         altsep = self.altsep
pathlib.py(68):         drv = root = ''
pathlib.py(69):         it = reversed(parts)
pathlib.py(70):         for part in it:
pathlib.py(71):             if not part:
pathlib.py(73):             if altsep:
pathlib.py(75):             drv, root, rel = self.splitroot(part)
 --- modulename: pathlib, funcname: splitroot
pathlib.py(294):         if part and part[0] == sep:
pathlib.py(306):             return '', '', part
pathlib.py(76):             if sep in rel:
pathlib.py(81):                 if rel and rel != '.':
pathlib.py(82):                     parsed.append(sys.intern(rel))
pathlib.py(83):             if drv or root:
pathlib.py(70):         for part in it:
pathlib.py(71):             if not part:
pathlib.py(73):             if altsep:
pathlib.py(75):             drv, root, rel = self.splitroot(part)
 --- modulename: pathlib, funcname: splitroot
pathlib.py(294):         if part and part[0] == sep:
pathlib.py(306):             return '', '', part
pathlib.py(76):             if sep in rel:
pathlib.py(81):                 if rel and rel != '.':
pathlib.py(82):                     parsed.append(sys.intern(rel))
pathlib.py(83):             if drv or root:
pathlib.py(70):         for part in it:
pathlib.py(71):             if not part:
pathlib.py(73):             if altsep:
pathlib.py(75):             drv, root, rel = self.splitroot(part)
 --- modulename: pathlib, funcname: splitroot
pathlib.py(294):         if part and part[0] == sep:
pathlib.py(306):             return '', '', part
pathlib.py(76):             if sep in rel:
pathlib.py(81):                 if rel and rel != '.':
pathlib.py(82):                     parsed.append(sys.intern(rel))
pathlib.py(83):             if drv or root:
pathlib.py(70):         for part in it:
pathlib.py(97):         if drv or root:
pathlib.py(99):         parsed.reverse()
pathlib.py(100):         return drv, root, parsed
pathlib.py(684):         self._drv = drv
pathlib.py(685):         self._root = root
pathlib.py(686):         self._parts = parts
pathlib.py(687):         if init:
pathlib.py(689):         return self
pathlib.py(1043):         if not self._flavour.is_supported:
pathlib.py(1046):         self._init()
 --- modulename: pathlib, funcname: _init
pathlib.py(1053):         self._closed = False
pathlib.py(1054):         if template is not None:
pathlib.py(1057):             self._accessor = _normal_accessor
pathlib.py(1047):         return self
file_io.py(30):     if not in_file.exists():
 --- modulename: pathlib, funcname: exists
pathlib.py(1406):         try:
pathlib.py(1407):             self.stat()
 --- modulename: pathlib, funcname: stat
pathlib.py(1198):         return self._accessor.stat(self)
 --- modulename: pathlib, funcname: __fspath__
pathlib.py(729):         return str(self)
 --- modulename: pathlib, funcname: __str__
pathlib.py(721):         try:
pathlib.py(722):             return self._str
pathlib.py(723):         except AttributeError:
pathlib.py(724):             self._str = self._format_parsed_parts(self._drv, self._root,
pathlib.py(725):                                                   self._parts) or '.'
pathlib.py(724):             self._str = self._format_parsed_parts(self._drv, self._root,
 --- modulename: pathlib, funcname: _format_parsed_parts
pathlib.py(703):         if drv or root:
pathlib.py(706):             return cls._flavour.join(parts)
pathlib.py(724):             self._str = self._format_parsed_parts(self._drv, self._root,
pathlib.py(726):             return self._str
pathlib.py(1415):         return True
file_io.py(34):     with open(str(in_file), "r") as f:
 --- modulename: pathlib, funcname: __str__
pathlib.py(721):         try:
pathlib.py(722):             return self._str
 --- modulename: _bootlocale, funcname: getpreferredencoding
_bootlocale.py(34):             assert not do_setlocale
_bootlocale.py(35):             if sys.flags.utf8_mode:
_bootlocale.py(37):             result = _locale.nl_langinfo(_locale.CODESET)
_bootlocale.py(38):             if not result and sys.platform == 'darwin':
_bootlocale.py(46):             return result
 --- modulename: codecs, funcname: __init__
codecs.py(310):         IncrementalDecoder.__init__(self, errors)
 --- modulename: codecs, funcname: __init__
codecs.py(268):         self.errors = errors
codecs.py(312):         self.buffer = b""
file_io.py(35):         rows = f.readlines()
 --- modulename: codecs, funcname: decode
codecs.py(321):         data = self.buffer + input
codecs.py(322):         (result, consumed) = self._buffer_decode(data, self.errors, final)
codecs.py(324):         self.buffer = data[consumed:]
codecs.py(325):         return result
 --- modulename: codecs, funcname: decode
codecs.py(321):         data = self.buffer + input
codecs.py(322):         (result, consumed) = self._buffer_decode(data, self.errors, final)
codecs.py(324):         self.buffer = data[consumed:]
codecs.py(325):         return result
 --- modulename: codecs, funcname: decode
codecs.py(321):         data = self.buffer + input
codecs.py(322):         (result, consumed) = self._buffer_decode(data, self.errors, final)
codecs.py(324):         self.buffer = data[consumed:]
codecs.py(325):         return result
file_io.py(38):     in_data = []
file_io.py(39):     line = 0
file_io.py(41):     for row in rows:
file_io.py(42):         line += 1
file_io.py(43):         n, m = row.replace("\ufeff", "").replace("\n", "").split(",")[:2]
file_io.py(46):         if line == 1:
file_io.py(47):             if (n != "n") or (m != "m"):
file_io.py(41):     for row in rows:
file_io.py(42):         line += 1
file_io.py(43):         n, m = row.replace("\ufeff", "").replace("\n", "").split(",")[:2]
file_io.py(46):         if line == 1:
file_io.py(55):         if (not n.isdigit()) or (not m.isdigit()):
file_io.py(60):         n, m = int(n), int(m)
file_io.py(63):         n_choose_2 = n_choose_k(n, 2)
 --- modulename: utils, funcname: n_choose_k
utils.py(30):     integers = (not isinstance(n, int)) or (not isinstance(m, int))
utils.py(31):     nonnegative = (n >= 0) and (m >= 0)
utils.py(32):     if integers and nonnegative:
utils.py(34):     if m > n:
utils.py(36):     return int(compute_factorial(n) / (compute_factorial(m) * compute_factorial(n - m)))
 --- modulename: utils, funcname: compute_factorial
utils.py(15):     if (not isinstance(n, int)) or (n < 0):
utils.py(17):     factorial = 1
utils.py(18):     for i in range(1, n + 1):
utils.py(19):         factorial *= i
utils.py(18):     for i in range(1, n + 1):
utils.py(19):         factorial *= i
utils.py(18):     for i in range(1, n + 1):
utils.py(20):     return factorial
 --- modulename: utils, funcname: compute_factorial
utils.py(15):     if (not isinstance(n, int)) or (n < 0):
utils.py(17):     factorial = 1
utils.py(18):     for i in range(1, n + 1):
utils.py(19):         factorial *= i
utils.py(18):     for i in range(1, n + 1):
utils.py(19):         factorial *= i
utils.py(18):     for i in range(1, n + 1):
utils.py(20):     return factorial
 --- modulename: utils, funcname: compute_factorial
utils.py(15):     if (not isinstance(n, int)) or (n < 0):
utils.py(17):     factorial = 1
utils.py(18):     for i in range(1, n + 1):
utils.py(20):     return factorial
file_io.py(64):         if m > n_choose_2:
file_io.py(69):         if n < 2:
file_io.py(73):         if m < 1:
file_io.py(77):         in_data.append([n, m])
file_io.py(41):     for row in rows:
file_io.py(79):     return in_data
run.py(45):     logging.debug("Iterate over each n, m pair")
 --- modulename: __init__, funcname: debug
__init__.py(2090):     if len(root.handlers) == 0:
__init__.py(2092):     root.debug(msg, *args, **kwargs)
 --- modulename: __init__, funcname: debug
__init__.py(1433):         if self.isEnabledFor(DEBUG):
 --- modulename: __init__, funcname: isEnabledFor
__init__.py(1693):         if self.disabled:
__init__.py(1696):         try:
__init__.py(1697):             return self._cache[level]
__init__.py(1434):             self._log(DEBUG, msg, args, **kwargs)
 --- modulename: __init__, funcname: _log
__init__.py(1571):         sinfo = None
__init__.py(1572):         if _srcfile:
__init__.py(1576):             try:
__init__.py(1577):                 fn, lno, func, sinfo = self.findCaller(stack_info, stacklevel)
 --- modulename: __init__, funcname: findCaller
__init__.py(1519):         f = currentframe()
 --- modulename: __init__, funcname: <lambda>
__init__.py(160):     currentframe = lambda: sys._getframe(3)
__init__.py(1522):         if f is not None:
__init__.py(1523):             f = f.f_back
__init__.py(1524):         orig_f = f
__init__.py(1525):         while f and stacklevel > 1:
__init__.py(1528):         if not f:
__init__.py(1530):         rv = "(unknown file)", 0, "(unknown function)", None
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1535):                 f = f.f_back
__init__.py(1536):                 continue
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1537):             sinfo = None
__init__.py(1538):             if stack_info:
__init__.py(1546):             rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)
__init__.py(1547):             break
__init__.py(1548):         return rv
__init__.py(1582):         if exc_info:
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
__init__.py(1588):                                  exc_info, func, extra, sinfo)
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
 --- modulename: __init__, funcname: makeRecord
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
__init__.py(1557):                              sinfo)
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
 --- modulename: __init__, funcname: __init__
__init__.py(293):         ct = time.time()
__init__.py(294):         self.name = name
__init__.py(295):         self.msg = msg
__init__.py(314):         if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)
__init__.py(317):         self.args = args
__init__.py(318):         self.levelname = getLevelName(level)
 --- modulename: __init__, funcname: getLevelName
__init__.py(138):     result = _levelToName.get(level)
__init__.py(139):     if result is not None:
__init__.py(140):         return result
__init__.py(319):         self.levelno = level
__init__.py(320):         self.pathname = pathname
__init__.py(321):         try:
__init__.py(322):             self.filename = os.path.basename(pathname)
 --- modulename: posixpath, funcname: basename
posixpath.py(142):     p = os.fspath(p)
posixpath.py(143):     sep = _get_sep(p)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(144):     i = p.rfind(sep) + 1
posixpath.py(145):     return p[i:]
__init__.py(323):             self.module = os.path.splitext(self.filename)[0]
 --- modulename: posixpath, funcname: splitext
posixpath.py(118):     p = os.fspath(p)
posixpath.py(119):     if isinstance(p, bytes):
posixpath.py(123):         sep = '/'
posixpath.py(124):         extsep = '.'
posixpath.py(125):     return genericpath._splitext(p, sep, None, extsep)
 --- modulename: genericpath, funcname: _splitext
genericpath.py(128):     sepIndex = p.rfind(sep)
genericpath.py(129):     if altsep:
genericpath.py(133):     dotIndex = p.rfind(extsep)
genericpath.py(134):     if dotIndex > sepIndex:
genericpath.py(136):         filenameIndex = sepIndex + 1
genericpath.py(137):         while filenameIndex < dotIndex:
genericpath.py(138):             if p[filenameIndex:filenameIndex+1] != extsep:
genericpath.py(139):                 return p[:dotIndex], p[dotIndex:]
__init__.py(327):         self.exc_info = exc_info
__init__.py(328):         self.exc_text = None      # used to cache the traceback text
__init__.py(329):         self.stack_info = sinfo
__init__.py(330):         self.lineno = lineno
__init__.py(331):         self.funcName = func
__init__.py(332):         self.created = ct
__init__.py(333):         self.msecs = (ct - int(ct)) * 1000
__init__.py(334):         self.relativeCreated = (self.created - _startTime) * 1000
__init__.py(335):         if logThreads:
__init__.py(336):             self.thread = threading.get_ident()
__init__.py(337):             self.threadName = threading.current_thread().name
 --- modulename: threading, funcname: current_thread
threading.py(1313):     try:
threading.py(1314):         return _active[get_ident()]
 --- modulename: threading, funcname: name
threading.py(1039):         assert self._initialized, "Thread.__init__() not called"
threading.py(1040):         return self._name
__init__.py(341):         if not logMultiprocessing: # pragma: no cover
__init__.py(344):             self.processName = 'MainProcess'
__init__.py(345):             mp = sys.modules.get('multiprocessing')
__init__.py(346):             if mp is not None:
__init__.py(355):         if logProcesses and hasattr(os, 'getpid'):
__init__.py(356):             self.process = os.getpid()
__init__.py(1558):         if extra is not None:
__init__.py(1563):         return rv
__init__.py(1589):         self.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(1598):         if (not self.disabled) and self.filter(record):
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(1599):             self.callHandlers(record)
 --- modulename: __init__, funcname: callHandlers
__init__.py(1655):         c = self
__init__.py(1656):         found = 0
__init__.py(1657):         while c:
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1659):                 found = found + 1
__init__.py(1660):                 if record.levelno >= hdlr.level:
__init__.py(1661):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(950):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(951):         if rv:
__init__.py(952):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(953):             try:
__init__.py(954):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1185):         if self.stream is None:
__init__.py(1187):         StreamHandler.emit(self, record)
 --- modulename: __init__, funcname: emit
__init__.py(1084):         try:
__init__.py(1085):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(925):         if self.formatter:
__init__.py(926):             fmt = self.formatter
__init__.py(929):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(668):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(371):         msg = str(self.msg)
__init__.py(372):         if self.args:
__init__.py(374):         return msg
__init__.py(669):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(637):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(428):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(670):             record.asctime = self.formatTime(record, self.datefmt)
 --- modulename: __init__, funcname: formatTime
__init__.py(606):         ct = self.converter(record.created)
__init__.py(607):         if datefmt:
__init__.py(610):             t = time.strftime(self.default_time_format, ct)
__init__.py(611):             s = self.default_msec_format % (t, record.msecs)
__init__.py(612):         return s
__init__.py(671):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(640):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(439):         try:
__init__.py(440):             return self._format(record)
 --- modulename: __init__, funcname: _format
__init__.py(436):         return self._fmt % record.__dict__
__init__.py(672):         if record.exc_info:
__init__.py(677):         if record.exc_text:
__init__.py(681):         if record.stack_info:
__init__.py(685):         return s
__init__.py(1086):             stream = self.stream
__init__.py(1088):             stream.write(msg + self.terminator)
__init__.py(1089):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1066):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(1067):         try:
__init__.py(1068):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1069):                 self.stream.flush()
__init__.py(1071):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(956):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(957):         return rv
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1662):             if not c.propagate:
__init__.py(1665):                 c = c.parent
__init__.py(1657):         while c:
__init__.py(1666):         if (found == 0):
run.py(46):     stats_output = [["n", "m", "n_dist_comps", "n_heapifies", "total_ops"]]
run.py(47):     closest_pairs_output = []
run.py(48):     for row in input_params:
run.py(49):         n, m = row
run.py(50):         logging.info(f"n={n}, m={m}")
 --- modulename: __init__, funcname: info
__init__.py(2080):     if len(root.handlers) == 0:
__init__.py(2082):     root.info(msg, *args, **kwargs)
 --- modulename: __init__, funcname: info
__init__.py(1445):         if self.isEnabledFor(INFO):
 --- modulename: __init__, funcname: isEnabledFor
__init__.py(1693):         if self.disabled:
__init__.py(1696):         try:
__init__.py(1697):             return self._cache[level]
__init__.py(1698):         except KeyError:
__init__.py(1699):             _acquireLock()
 --- modulename: __init__, funcname: _acquireLock
__init__.py(224):     if _lock:
__init__.py(225):         _lock.acquire()
__init__.py(1700):             try:
__init__.py(1701):                 if self.manager.disable >= level:
 --- modulename: __init__, funcname: disable
__init__.py(1278):         return self._disable
__init__.py(1705):                         level >= self.getEffectiveLevel()
 --- modulename: __init__, funcname: getEffectiveLevel
__init__.py(1682):         logger = self
__init__.py(1683):         while logger:
__init__.py(1684):             if logger.level:
__init__.py(1685):                 return logger.level
__init__.py(1704):                     is_enabled = self._cache[level] = (
__init__.py(1708):                 _releaseLock()
 --- modulename: __init__, funcname: _releaseLock
__init__.py(231):     if _lock:
__init__.py(232):         _lock.release()
__init__.py(1709):             return is_enabled
__init__.py(1446):             self._log(INFO, msg, args, **kwargs)
 --- modulename: __init__, funcname: _log
__init__.py(1571):         sinfo = None
__init__.py(1572):         if _srcfile:
__init__.py(1576):             try:
__init__.py(1577):                 fn, lno, func, sinfo = self.findCaller(stack_info, stacklevel)
 --- modulename: __init__, funcname: findCaller
__init__.py(1519):         f = currentframe()
 --- modulename: __init__, funcname: <lambda>
__init__.py(160):     currentframe = lambda: sys._getframe(3)
__init__.py(1522):         if f is not None:
__init__.py(1523):             f = f.f_back
__init__.py(1524):         orig_f = f
__init__.py(1525):         while f and stacklevel > 1:
__init__.py(1528):         if not f:
__init__.py(1530):         rv = "(unknown file)", 0, "(unknown function)", None
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1535):                 f = f.f_back
__init__.py(1536):                 continue
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1537):             sinfo = None
__init__.py(1538):             if stack_info:
__init__.py(1546):             rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)
__init__.py(1547):             break
__init__.py(1548):         return rv
__init__.py(1582):         if exc_info:
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
__init__.py(1588):                                  exc_info, func, extra, sinfo)
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
 --- modulename: __init__, funcname: makeRecord
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
__init__.py(1557):                              sinfo)
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
 --- modulename: __init__, funcname: __init__
__init__.py(293):         ct = time.time()
__init__.py(294):         self.name = name
__init__.py(295):         self.msg = msg
__init__.py(314):         if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)
__init__.py(317):         self.args = args
__init__.py(318):         self.levelname = getLevelName(level)
 --- modulename: __init__, funcname: getLevelName
__init__.py(138):     result = _levelToName.get(level)
__init__.py(139):     if result is not None:
__init__.py(140):         return result
__init__.py(319):         self.levelno = level
__init__.py(320):         self.pathname = pathname
__init__.py(321):         try:
__init__.py(322):             self.filename = os.path.basename(pathname)
 --- modulename: posixpath, funcname: basename
posixpath.py(142):     p = os.fspath(p)
posixpath.py(143):     sep = _get_sep(p)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(144):     i = p.rfind(sep) + 1
posixpath.py(145):     return p[i:]
__init__.py(323):             self.module = os.path.splitext(self.filename)[0]
 --- modulename: posixpath, funcname: splitext
posixpath.py(118):     p = os.fspath(p)
posixpath.py(119):     if isinstance(p, bytes):
posixpath.py(123):         sep = '/'
posixpath.py(124):         extsep = '.'
posixpath.py(125):     return genericpath._splitext(p, sep, None, extsep)
 --- modulename: genericpath, funcname: _splitext
genericpath.py(128):     sepIndex = p.rfind(sep)
genericpath.py(129):     if altsep:
genericpath.py(133):     dotIndex = p.rfind(extsep)
genericpath.py(134):     if dotIndex > sepIndex:
genericpath.py(136):         filenameIndex = sepIndex + 1
genericpath.py(137):         while filenameIndex < dotIndex:
genericpath.py(138):             if p[filenameIndex:filenameIndex+1] != extsep:
genericpath.py(139):                 return p[:dotIndex], p[dotIndex:]
__init__.py(327):         self.exc_info = exc_info
__init__.py(328):         self.exc_text = None      # used to cache the traceback text
__init__.py(329):         self.stack_info = sinfo
__init__.py(330):         self.lineno = lineno
__init__.py(331):         self.funcName = func
__init__.py(332):         self.created = ct
__init__.py(333):         self.msecs = (ct - int(ct)) * 1000
__init__.py(334):         self.relativeCreated = (self.created - _startTime) * 1000
__init__.py(335):         if logThreads:
__init__.py(336):             self.thread = threading.get_ident()
__init__.py(337):             self.threadName = threading.current_thread().name
 --- modulename: threading, funcname: current_thread
threading.py(1313):     try:
threading.py(1314):         return _active[get_ident()]
 --- modulename: threading, funcname: name
threading.py(1039):         assert self._initialized, "Thread.__init__() not called"
threading.py(1040):         return self._name
__init__.py(341):         if not logMultiprocessing: # pragma: no cover
__init__.py(344):             self.processName = 'MainProcess'
__init__.py(345):             mp = sys.modules.get('multiprocessing')
__init__.py(346):             if mp is not None:
__init__.py(355):         if logProcesses and hasattr(os, 'getpid'):
__init__.py(356):             self.process = os.getpid()
__init__.py(1558):         if extra is not None:
__init__.py(1563):         return rv
__init__.py(1589):         self.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(1598):         if (not self.disabled) and self.filter(record):
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(1599):             self.callHandlers(record)
 --- modulename: __init__, funcname: callHandlers
__init__.py(1655):         c = self
__init__.py(1656):         found = 0
__init__.py(1657):         while c:
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1659):                 found = found + 1
__init__.py(1660):                 if record.levelno >= hdlr.level:
__init__.py(1661):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(950):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(951):         if rv:
__init__.py(952):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(953):             try:
__init__.py(954):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1185):         if self.stream is None:
__init__.py(1187):         StreamHandler.emit(self, record)
 --- modulename: __init__, funcname: emit
__init__.py(1084):         try:
__init__.py(1085):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(925):         if self.formatter:
__init__.py(926):             fmt = self.formatter
__init__.py(929):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(668):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(371):         msg = str(self.msg)
__init__.py(372):         if self.args:
__init__.py(374):         return msg
__init__.py(669):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(637):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(428):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(670):             record.asctime = self.formatTime(record, self.datefmt)
 --- modulename: __init__, funcname: formatTime
__init__.py(606):         ct = self.converter(record.created)
__init__.py(607):         if datefmt:
__init__.py(610):             t = time.strftime(self.default_time_format, ct)
__init__.py(611):             s = self.default_msec_format % (t, record.msecs)
__init__.py(612):         return s
__init__.py(671):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(640):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(439):         try:
__init__.py(440):             return self._format(record)
 --- modulename: __init__, funcname: _format
__init__.py(436):         return self._fmt % record.__dict__
__init__.py(672):         if record.exc_info:
__init__.py(677):         if record.exc_text:
__init__.py(681):         if record.stack_info:
__init__.py(685):         return s
__init__.py(1086):             stream = self.stream
__init__.py(1088):             stream.write(msg + self.terminator)
__init__.py(1089):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1066):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(1067):         try:
__init__.py(1068):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1069):                 self.stream.flush()
__init__.py(1071):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(956):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(957):         return rv
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1662):             if not c.propagate:
__init__.py(1665):                 c = c.parent
__init__.py(1657):         while c:
__init__.py(1666):         if (found == 0):
run.py(53):         data_maker = DataMaker(n, seed=seed)
 --- modulename: datamaker, funcname: __init__
datamaker.py(29):         self.n = n
datamaker.py(30):         self.seed = seed
datamaker.py(31):         self.a = a
datamaker.py(32):         self.c = c
datamaker.py(33):         self.m = m
datamaker.py(34):         self.points = []
run.py(54):         points: List[List[Union[int, float]]] = data_maker.make_data()
 --- modulename: datamaker, funcname: make_data
datamaker.py(41):         seed = self.seed
datamaker.py(42):         for i in range(self.n):
datamaker.py(43):             temp = []
datamaker.py(44):             seed = self.make_pseudo_random(self.a, self.c, self.m, seed)
 --- modulename: datamaker, funcname: make_pseudo_random
datamaker.py(61):         return (a * seed + c) % m
datamaker.py(45):             temp.append(seed)
datamaker.py(46):             seed = self.make_pseudo_random(self.a, self.c, self.m, seed)
 --- modulename: datamaker, funcname: make_pseudo_random
datamaker.py(61):         return (a * seed + c) % m
datamaker.py(47):             temp.append(seed)
datamaker.py(48):             self.points.append(temp)
datamaker.py(42):         for i in range(self.n):
datamaker.py(43):             temp = []
datamaker.py(44):             seed = self.make_pseudo_random(self.a, self.c, self.m, seed)
 --- modulename: datamaker, funcname: make_pseudo_random
datamaker.py(61):         return (a * seed + c) % m
datamaker.py(45):             temp.append(seed)
datamaker.py(46):             seed = self.make_pseudo_random(self.a, self.c, self.m, seed)
 --- modulename: datamaker, funcname: make_pseudo_random
datamaker.py(61):         return (a * seed + c) % m
datamaker.py(47):             temp.append(seed)
datamaker.py(48):             self.points.append(temp)
datamaker.py(42):         for i in range(self.n):
datamaker.py(49):         return self.points
run.py(57):         distance_computer = DistanceComputer(points)
 --- modulename: distance_computer, funcname: __init__
distance_computer.py(23):         self.raw_points = raw_points
distance_computer.py(24):         self.distances: Union[List[dict], None] = None
distance_computer.py(25):         self.n_dist_comps: int = 0
run.py(58):         points = distance_computer.compute_distances()
 --- modulename: distance_computer, funcname: compute_distances
distance_computer.py(32):         self.distances = []
distance_computer.py(33):         for i in range(len(self.raw_points)):
distance_computer.py(34):             for j in range(i + 1, len(self.raw_points)):
distance_computer.py(35):                 distance = self.compute_distance(self.raw_points[i], self.raw_points[j])
 --- modulename: distance_computer, funcname: compute_distance
distance_computer.py(49):         x1, y1 = p1
distance_computer.py(50):         x2, y2 = p2
distance_computer.py(51):         return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** (1 / 2)
distance_computer.py(36):                 li = [self.raw_points[i], self.raw_points[j], distance]
distance_computer.py(37):                 self.distances.append(li)
distance_computer.py(38):                 self.n_dist_comps += 1
distance_computer.py(34):             for j in range(i + 1, len(self.raw_points)):
distance_computer.py(33):         for i in range(len(self.raw_points)):
distance_computer.py(34):             for j in range(i + 1, len(self.raw_points)):
distance_computer.py(33):         for i in range(len(self.raw_points)):
distance_computer.py(39):         return self.distances
run.py(61):         heap_sort_points = HeapSortPoints(points)
 --- modulename: heap_sort_points, funcname: __init__
heap_sort_points.py(22):         super().__init__(li)
 --- modulename: heap_sort, funcname: __init__
heap_sort.py(23):         self.li = li
heap_sort.py(24):         self.heap_size = len(li)
heap_sort.py(25):         self.length = len(li)
heap_sort.py(26):         self.n_heapifies = 0
heap_sort_points.py(23):         self.li = li
run.py(62):         points = heap_sort_points.sort()
 --- modulename: heap_sort_points, funcname: sort
heap_sort_points.py(48):         self.build_max_heap()
 --- modulename: heap_sort, funcname: build_max_heap
heap_sort.py(32):         for i in reversed(range(len(self.li) // 2)):
heap_sort_points.py(49):         for i in reversed(range(1, self.length)):
heap_sort_points.py(54):         return self.li
run.py(65):         m_closest_pairs = points[:m]
run.py(68):         total_ops = distance_computer.n_dist_comps + heap_sort_points.n_heapifies
run.py(71):         di = {"n": n, "m": m, "m_closest_pairs": m_closest_pairs, "all_points": data_maker.points}
run.py(72):         closest_pairs_output.append(di)
run.py(75):         li = [n, m, distance_computer.n_dist_comps, heap_sort_points.n_heapifies, total_ops]
run.py(76):         stats_output.append(li)
run.py(48):     for row in input_params:
run.py(78):     logging.debug("Write performance outputs to CSV.")
 --- modulename: __init__, funcname: debug
__init__.py(2090):     if len(root.handlers) == 0:
__init__.py(2092):     root.debug(msg, *args, **kwargs)
 --- modulename: __init__, funcname: debug
__init__.py(1433):         if self.isEnabledFor(DEBUG):
 --- modulename: __init__, funcname: isEnabledFor
__init__.py(1693):         if self.disabled:
__init__.py(1696):         try:
__init__.py(1697):             return self._cache[level]
__init__.py(1434):             self._log(DEBUG, msg, args, **kwargs)
 --- modulename: __init__, funcname: _log
__init__.py(1571):         sinfo = None
__init__.py(1572):         if _srcfile:
__init__.py(1576):             try:
__init__.py(1577):                 fn, lno, func, sinfo = self.findCaller(stack_info, stacklevel)
 --- modulename: __init__, funcname: findCaller
__init__.py(1519):         f = currentframe()
 --- modulename: __init__, funcname: <lambda>
__init__.py(160):     currentframe = lambda: sys._getframe(3)
__init__.py(1522):         if f is not None:
__init__.py(1523):             f = f.f_back
__init__.py(1524):         orig_f = f
__init__.py(1525):         while f and stacklevel > 1:
__init__.py(1528):         if not f:
__init__.py(1530):         rv = "(unknown file)", 0, "(unknown function)", None
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1535):                 f = f.f_back
__init__.py(1536):                 continue
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1537):             sinfo = None
__init__.py(1538):             if stack_info:
__init__.py(1546):             rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)
__init__.py(1547):             break
__init__.py(1548):         return rv
__init__.py(1582):         if exc_info:
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
__init__.py(1588):                                  exc_info, func, extra, sinfo)
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
 --- modulename: __init__, funcname: makeRecord
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
__init__.py(1557):                              sinfo)
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
 --- modulename: __init__, funcname: __init__
__init__.py(293):         ct = time.time()
__init__.py(294):         self.name = name
__init__.py(295):         self.msg = msg
__init__.py(314):         if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)
__init__.py(317):         self.args = args
__init__.py(318):         self.levelname = getLevelName(level)
 --- modulename: __init__, funcname: getLevelName
__init__.py(138):     result = _levelToName.get(level)
__init__.py(139):     if result is not None:
__init__.py(140):         return result
__init__.py(319):         self.levelno = level
__init__.py(320):         self.pathname = pathname
__init__.py(321):         try:
__init__.py(322):             self.filename = os.path.basename(pathname)
 --- modulename: posixpath, funcname: basename
posixpath.py(142):     p = os.fspath(p)
posixpath.py(143):     sep = _get_sep(p)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(144):     i = p.rfind(sep) + 1
posixpath.py(145):     return p[i:]
__init__.py(323):             self.module = os.path.splitext(self.filename)[0]
 --- modulename: posixpath, funcname: splitext
posixpath.py(118):     p = os.fspath(p)
posixpath.py(119):     if isinstance(p, bytes):
posixpath.py(123):         sep = '/'
posixpath.py(124):         extsep = '.'
posixpath.py(125):     return genericpath._splitext(p, sep, None, extsep)
 --- modulename: genericpath, funcname: _splitext
genericpath.py(128):     sepIndex = p.rfind(sep)
genericpath.py(129):     if altsep:
genericpath.py(133):     dotIndex = p.rfind(extsep)
genericpath.py(134):     if dotIndex > sepIndex:
genericpath.py(136):         filenameIndex = sepIndex + 1
genericpath.py(137):         while filenameIndex < dotIndex:
genericpath.py(138):             if p[filenameIndex:filenameIndex+1] != extsep:
genericpath.py(139):                 return p[:dotIndex], p[dotIndex:]
__init__.py(327):         self.exc_info = exc_info
__init__.py(328):         self.exc_text = None      # used to cache the traceback text
__init__.py(329):         self.stack_info = sinfo
__init__.py(330):         self.lineno = lineno
__init__.py(331):         self.funcName = func
__init__.py(332):         self.created = ct
__init__.py(333):         self.msecs = (ct - int(ct)) * 1000
__init__.py(334):         self.relativeCreated = (self.created - _startTime) * 1000
__init__.py(335):         if logThreads:
__init__.py(336):             self.thread = threading.get_ident()
__init__.py(337):             self.threadName = threading.current_thread().name
 --- modulename: threading, funcname: current_thread
threading.py(1313):     try:
threading.py(1314):         return _active[get_ident()]
 --- modulename: threading, funcname: name
threading.py(1039):         assert self._initialized, "Thread.__init__() not called"
threading.py(1040):         return self._name
__init__.py(341):         if not logMultiprocessing: # pragma: no cover
__init__.py(344):             self.processName = 'MainProcess'
__init__.py(345):             mp = sys.modules.get('multiprocessing')
__init__.py(346):             if mp is not None:
__init__.py(355):         if logProcesses and hasattr(os, 'getpid'):
__init__.py(356):             self.process = os.getpid()
__init__.py(1558):         if extra is not None:
__init__.py(1563):         return rv
__init__.py(1589):         self.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(1598):         if (not self.disabled) and self.filter(record):
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(1599):             self.callHandlers(record)
 --- modulename: __init__, funcname: callHandlers
__init__.py(1655):         c = self
__init__.py(1656):         found = 0
__init__.py(1657):         while c:
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1659):                 found = found + 1
__init__.py(1660):                 if record.levelno >= hdlr.level:
__init__.py(1661):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(950):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(951):         if rv:
__init__.py(952):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(953):             try:
__init__.py(954):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1185):         if self.stream is None:
__init__.py(1187):         StreamHandler.emit(self, record)
 --- modulename: __init__, funcname: emit
__init__.py(1084):         try:
__init__.py(1085):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(925):         if self.formatter:
__init__.py(926):             fmt = self.formatter
__init__.py(929):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(668):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(371):         msg = str(self.msg)
__init__.py(372):         if self.args:
__init__.py(374):         return msg
__init__.py(669):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(637):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(428):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(670):             record.asctime = self.formatTime(record, self.datefmt)
 --- modulename: __init__, funcname: formatTime
__init__.py(606):         ct = self.converter(record.created)
__init__.py(607):         if datefmt:
__init__.py(610):             t = time.strftime(self.default_time_format, ct)
__init__.py(611):             s = self.default_msec_format % (t, record.msecs)
__init__.py(612):         return s
__init__.py(671):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(640):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(439):         try:
__init__.py(440):             return self._format(record)
 --- modulename: __init__, funcname: _format
__init__.py(436):         return self._fmt % record.__dict__
__init__.py(672):         if record.exc_info:
__init__.py(677):         if record.exc_text:
__init__.py(681):         if record.stack_info:
__init__.py(685):         return s
__init__.py(1086):             stream = self.stream
__init__.py(1088):             stream.write(msg + self.terminator)
__init__.py(1089):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1066):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(1067):         try:
__init__.py(1068):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1069):                 self.stream.flush()
__init__.py(1071):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(956):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(957):         return rv
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1662):             if not c.propagate:
__init__.py(1665):                 c = c.parent
__init__.py(1657):         while c:
__init__.py(1666):         if (found == 0):
run.py(79):     stats_dst = dst_dir / f"{src.stem}_output.csv"
 --- modulename: pathlib, funcname: stem
pathlib.py(842):         name = self.name
 --- modulename: pathlib, funcname: name
pathlib.py(807):         parts = self._parts
pathlib.py(808):         if len(parts) == (1 if (self._drv or self._root) else 0):
pathlib.py(810):         return parts[-1]
pathlib.py(843):         i = name.rfind('.')
pathlib.py(844):         if 0 < i < len(name) - 1:
pathlib.py(845):             return name[:i]
 --- modulename: pathlib, funcname: __truediv__
pathlib.py(934):         try:
pathlib.py(935):             return self._make_child((key,))
 --- modulename: pathlib, funcname: _make_child
pathlib.py(713):         drv, root, parts = self._parse_args(args)
 --- modulename: pathlib, funcname: _parse_args
pathlib.py(662):         parts = []
pathlib.py(663):         for a in args:
pathlib.py(664):             if isinstance(a, PurePath):
pathlib.py(667):                 a = os.fspath(a)
pathlib.py(668):                 if isinstance(a, str):
pathlib.py(670):                     parts.append(str(a))
pathlib.py(663):         for a in args:
pathlib.py(676):         return cls._flavour.parse_parts(parts)
 --- modulename: pathlib, funcname: parse_parts
pathlib.py(65):         parsed = []
pathlib.py(66):         sep = self.sep
pathlib.py(67):         altsep = self.altsep
pathlib.py(68):         drv = root = ''
pathlib.py(69):         it = reversed(parts)
pathlib.py(70):         for part in it:
pathlib.py(71):             if not part:
pathlib.py(73):             if altsep:
pathlib.py(75):             drv, root, rel = self.splitroot(part)
 --- modulename: pathlib, funcname: splitroot
pathlib.py(294):         if part and part[0] == sep:
pathlib.py(306):             return '', '', part
pathlib.py(76):             if sep in rel:
pathlib.py(81):                 if rel and rel != '.':
pathlib.py(82):                     parsed.append(sys.intern(rel))
pathlib.py(83):             if drv or root:
pathlib.py(70):         for part in it:
pathlib.py(97):         if drv or root:
pathlib.py(99):         parsed.reverse()
pathlib.py(100):         return drv, root, parsed
pathlib.py(714):         drv, root, parts = self._flavour.join_parsed_parts(
pathlib.py(715):             self._drv, self._root, self._parts, drv, root, parts)
pathlib.py(714):         drv, root, parts = self._flavour.join_parsed_parts(
 --- modulename: pathlib, funcname: join_parsed_parts
pathlib.py(107):         if root2:
pathlib.py(110):         elif drv2:
pathlib.py(116):             return drv, root, parts + parts2
pathlib.py(716):         return self._from_parsed_parts(drv, root, parts)
 --- modulename: pathlib, funcname: _from_parsed_parts
pathlib.py(693):         self = object.__new__(cls)
pathlib.py(694):         self._drv = drv
pathlib.py(695):         self._root = root
pathlib.py(696):         self._parts = parts
pathlib.py(697):         if init:
pathlib.py(698):             self._init()
 --- modulename: pathlib, funcname: _init
pathlib.py(1053):         self._closed = False
pathlib.py(1054):         if template is not None:
pathlib.py(1057):             self._accessor = _normal_accessor
pathlib.py(699):         return self
run.py(80):     write_stats_outputs(stats_dst, file_header, stats_output)
 --- modulename: file_io, funcname: write_stats_outputs
file_io.py(100):     with open(dst, "w") as f:
 --- modulename: pathlib, funcname: __fspath__
pathlib.py(729):         return str(self)
 --- modulename: pathlib, funcname: __str__
pathlib.py(721):         try:
pathlib.py(722):             return self._str
pathlib.py(723):         except AttributeError:
pathlib.py(724):             self._str = self._format_parsed_parts(self._drv, self._root,
pathlib.py(725):                                                   self._parts) or '.'
pathlib.py(724):             self._str = self._format_parsed_parts(self._drv, self._root,
 --- modulename: pathlib, funcname: _format_parsed_parts
pathlib.py(703):         if drv or root:
pathlib.py(706):             return cls._flavour.join(parts)
pathlib.py(724):             self._str = self._format_parsed_parts(self._drv, self._root,
pathlib.py(726):             return self._str
 --- modulename: _bootlocale, funcname: getpreferredencoding
_bootlocale.py(34):             assert not do_setlocale
_bootlocale.py(35):             if sys.flags.utf8_mode:
_bootlocale.py(37):             result = _locale.nl_langinfo(_locale.CODESET)
_bootlocale.py(38):             if not result and sys.platform == 'darwin':
_bootlocale.py(46):             return result
 --- modulename: codecs, funcname: __init__
codecs.py(194):         self.errors = errors
codecs.py(195):         self.buffer = ""
file_io.py(101):         f.write(f"# {file_header}\n")
file_io.py(102):         writer = csv.writer(f)
file_io.py(103):         writer.writerows(stats_output)
run.py(82):     logging.debug("Write set of m closest pairs for given n to JSON.")
 --- modulename: __init__, funcname: debug
__init__.py(2090):     if len(root.handlers) == 0:
__init__.py(2092):     root.debug(msg, *args, **kwargs)
 --- modulename: __init__, funcname: debug
__init__.py(1433):         if self.isEnabledFor(DEBUG):
 --- modulename: __init__, funcname: isEnabledFor
__init__.py(1693):         if self.disabled:
__init__.py(1696):         try:
__init__.py(1697):             return self._cache[level]
__init__.py(1434):             self._log(DEBUG, msg, args, **kwargs)
 --- modulename: __init__, funcname: _log
__init__.py(1571):         sinfo = None
__init__.py(1572):         if _srcfile:
__init__.py(1576):             try:
__init__.py(1577):                 fn, lno, func, sinfo = self.findCaller(stack_info, stacklevel)
 --- modulename: __init__, funcname: findCaller
__init__.py(1519):         f = currentframe()
 --- modulename: __init__, funcname: <lambda>
__init__.py(160):     currentframe = lambda: sys._getframe(3)
__init__.py(1522):         if f is not None:
__init__.py(1523):             f = f.f_back
__init__.py(1524):         orig_f = f
__init__.py(1525):         while f and stacklevel > 1:
__init__.py(1528):         if not f:
__init__.py(1530):         rv = "(unknown file)", 0, "(unknown function)", None
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1535):                 f = f.f_back
__init__.py(1536):                 continue
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1537):             sinfo = None
__init__.py(1538):             if stack_info:
__init__.py(1546):             rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)
__init__.py(1547):             break
__init__.py(1548):         return rv
__init__.py(1582):         if exc_info:
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
__init__.py(1588):                                  exc_info, func, extra, sinfo)
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
 --- modulename: __init__, funcname: makeRecord
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
__init__.py(1557):                              sinfo)
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
 --- modulename: __init__, funcname: __init__
__init__.py(293):         ct = time.time()
__init__.py(294):         self.name = name
__init__.py(295):         self.msg = msg
__init__.py(314):         if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)
__init__.py(317):         self.args = args
__init__.py(318):         self.levelname = getLevelName(level)
 --- modulename: __init__, funcname: getLevelName
__init__.py(138):     result = _levelToName.get(level)
__init__.py(139):     if result is not None:
__init__.py(140):         return result
__init__.py(319):         self.levelno = level
__init__.py(320):         self.pathname = pathname
__init__.py(321):         try:
__init__.py(322):             self.filename = os.path.basename(pathname)
 --- modulename: posixpath, funcname: basename
posixpath.py(142):     p = os.fspath(p)
posixpath.py(143):     sep = _get_sep(p)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(144):     i = p.rfind(sep) + 1
posixpath.py(145):     return p[i:]
__init__.py(323):             self.module = os.path.splitext(self.filename)[0]
 --- modulename: posixpath, funcname: splitext
posixpath.py(118):     p = os.fspath(p)
posixpath.py(119):     if isinstance(p, bytes):
posixpath.py(123):         sep = '/'
posixpath.py(124):         extsep = '.'
posixpath.py(125):     return genericpath._splitext(p, sep, None, extsep)
 --- modulename: genericpath, funcname: _splitext
genericpath.py(128):     sepIndex = p.rfind(sep)
genericpath.py(129):     if altsep:
genericpath.py(133):     dotIndex = p.rfind(extsep)
genericpath.py(134):     if dotIndex > sepIndex:
genericpath.py(136):         filenameIndex = sepIndex + 1
genericpath.py(137):         while filenameIndex < dotIndex:
genericpath.py(138):             if p[filenameIndex:filenameIndex+1] != extsep:
genericpath.py(139):                 return p[:dotIndex], p[dotIndex:]
__init__.py(327):         self.exc_info = exc_info
__init__.py(328):         self.exc_text = None      # used to cache the traceback text
__init__.py(329):         self.stack_info = sinfo
__init__.py(330):         self.lineno = lineno
__init__.py(331):         self.funcName = func
__init__.py(332):         self.created = ct
__init__.py(333):         self.msecs = (ct - int(ct)) * 1000
__init__.py(334):         self.relativeCreated = (self.created - _startTime) * 1000
__init__.py(335):         if logThreads:
__init__.py(336):             self.thread = threading.get_ident()
__init__.py(337):             self.threadName = threading.current_thread().name
 --- modulename: threading, funcname: current_thread
threading.py(1313):     try:
threading.py(1314):         return _active[get_ident()]
 --- modulename: threading, funcname: name
threading.py(1039):         assert self._initialized, "Thread.__init__() not called"
threading.py(1040):         return self._name
__init__.py(341):         if not logMultiprocessing: # pragma: no cover
__init__.py(344):             self.processName = 'MainProcess'
__init__.py(345):             mp = sys.modules.get('multiprocessing')
__init__.py(346):             if mp is not None:
__init__.py(355):         if logProcesses and hasattr(os, 'getpid'):
__init__.py(356):             self.process = os.getpid()
__init__.py(1558):         if extra is not None:
__init__.py(1563):         return rv
__init__.py(1589):         self.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(1598):         if (not self.disabled) and self.filter(record):
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(1599):             self.callHandlers(record)
 --- modulename: __init__, funcname: callHandlers
__init__.py(1655):         c = self
__init__.py(1656):         found = 0
__init__.py(1657):         while c:
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1659):                 found = found + 1
__init__.py(1660):                 if record.levelno >= hdlr.level:
__init__.py(1661):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(950):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(951):         if rv:
__init__.py(952):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(953):             try:
__init__.py(954):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1185):         if self.stream is None:
__init__.py(1187):         StreamHandler.emit(self, record)
 --- modulename: __init__, funcname: emit
__init__.py(1084):         try:
__init__.py(1085):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(925):         if self.formatter:
__init__.py(926):             fmt = self.formatter
__init__.py(929):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(668):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(371):         msg = str(self.msg)
__init__.py(372):         if self.args:
__init__.py(374):         return msg
__init__.py(669):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(637):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(428):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(670):             record.asctime = self.formatTime(record, self.datefmt)
 --- modulename: __init__, funcname: formatTime
__init__.py(606):         ct = self.converter(record.created)
__init__.py(607):         if datefmt:
__init__.py(610):             t = time.strftime(self.default_time_format, ct)
__init__.py(611):             s = self.default_msec_format % (t, record.msecs)
__init__.py(612):         return s
__init__.py(671):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(640):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(439):         try:
__init__.py(440):             return self._format(record)
 --- modulename: __init__, funcname: _format
__init__.py(436):         return self._fmt % record.__dict__
__init__.py(672):         if record.exc_info:
__init__.py(677):         if record.exc_text:
__init__.py(681):         if record.stack_info:
__init__.py(685):         return s
__init__.py(1086):             stream = self.stream
__init__.py(1088):             stream.write(msg + self.terminator)
__init__.py(1089):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1066):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(1067):         try:
__init__.py(1068):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1069):                 self.stream.flush()
__init__.py(1071):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(956):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(957):         return rv
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1662):             if not c.propagate:
__init__.py(1665):                 c = c.parent
__init__.py(1657):         while c:
__init__.py(1666):         if (found == 0):
run.py(83):     closest_pairs_dst = dst_dir / f"{src.stem}_output.json"
 --- modulename: pathlib, funcname: stem
pathlib.py(842):         name = self.name
 --- modulename: pathlib, funcname: name
pathlib.py(807):         parts = self._parts
pathlib.py(808):         if len(parts) == (1 if (self._drv or self._root) else 0):
pathlib.py(810):         return parts[-1]
pathlib.py(843):         i = name.rfind('.')
pathlib.py(844):         if 0 < i < len(name) - 1:
pathlib.py(845):             return name[:i]
 --- modulename: pathlib, funcname: __truediv__
pathlib.py(934):         try:
pathlib.py(935):             return self._make_child((key,))
 --- modulename: pathlib, funcname: _make_child
pathlib.py(713):         drv, root, parts = self._parse_args(args)
 --- modulename: pathlib, funcname: _parse_args
pathlib.py(662):         parts = []
pathlib.py(663):         for a in args:
pathlib.py(664):             if isinstance(a, PurePath):
pathlib.py(667):                 a = os.fspath(a)
pathlib.py(668):                 if isinstance(a, str):
pathlib.py(670):                     parts.append(str(a))
pathlib.py(663):         for a in args:
pathlib.py(676):         return cls._flavour.parse_parts(parts)
 --- modulename: pathlib, funcname: parse_parts
pathlib.py(65):         parsed = []
pathlib.py(66):         sep = self.sep
pathlib.py(67):         altsep = self.altsep
pathlib.py(68):         drv = root = ''
pathlib.py(69):         it = reversed(parts)
pathlib.py(70):         for part in it:
pathlib.py(71):             if not part:
pathlib.py(73):             if altsep:
pathlib.py(75):             drv, root, rel = self.splitroot(part)
 --- modulename: pathlib, funcname: splitroot
pathlib.py(294):         if part and part[0] == sep:
pathlib.py(306):             return '', '', part
pathlib.py(76):             if sep in rel:
pathlib.py(81):                 if rel and rel != '.':
pathlib.py(82):                     parsed.append(sys.intern(rel))
pathlib.py(83):             if drv or root:
pathlib.py(70):         for part in it:
pathlib.py(97):         if drv or root:
pathlib.py(99):         parsed.reverse()
pathlib.py(100):         return drv, root, parsed
pathlib.py(714):         drv, root, parts = self._flavour.join_parsed_parts(
pathlib.py(715):             self._drv, self._root, self._parts, drv, root, parts)
pathlib.py(714):         drv, root, parts = self._flavour.join_parsed_parts(
 --- modulename: pathlib, funcname: join_parsed_parts
pathlib.py(107):         if root2:
pathlib.py(110):         elif drv2:
pathlib.py(116):             return drv, root, parts + parts2
pathlib.py(716):         return self._from_parsed_parts(drv, root, parts)
 --- modulename: pathlib, funcname: _from_parsed_parts
pathlib.py(693):         self = object.__new__(cls)
pathlib.py(694):         self._drv = drv
pathlib.py(695):         self._root = root
pathlib.py(696):         self._parts = parts
pathlib.py(697):         if init:
pathlib.py(698):             self._init()
 --- modulename: pathlib, funcname: _init
pathlib.py(1053):         self._closed = False
pathlib.py(1054):         if template is not None:
pathlib.py(1057):             self._accessor = _normal_accessor
pathlib.py(699):         return self
run.py(84):     write_closest_pairs_outputs(closest_pairs_dst, closest_pairs_output)
 --- modulename: file_io, funcname: write_closest_pairs_outputs
file_io.py(88):     with open(dst, "w") as f:
 --- modulename: pathlib, funcname: __fspath__
pathlib.py(729):         return str(self)
 --- modulename: pathlib, funcname: __str__
pathlib.py(721):         try:
pathlib.py(722):             return self._str
pathlib.py(723):         except AttributeError:
pathlib.py(724):             self._str = self._format_parsed_parts(self._drv, self._root,
pathlib.py(725):                                                   self._parts) or '.'
pathlib.py(724):             self._str = self._format_parsed_parts(self._drv, self._root,
 --- modulename: pathlib, funcname: _format_parsed_parts
pathlib.py(703):         if drv or root:
pathlib.py(706):             return cls._flavour.join(parts)
pathlib.py(724):             self._str = self._format_parsed_parts(self._drv, self._root,
pathlib.py(726):             return self._str
 --- modulename: _bootlocale, funcname: getpreferredencoding
_bootlocale.py(34):             assert not do_setlocale
_bootlocale.py(35):             if sys.flags.utf8_mode:
_bootlocale.py(37):             result = _locale.nl_langinfo(_locale.CODESET)
_bootlocale.py(38):             if not result and sys.platform == 'darwin':
_bootlocale.py(46):             return result
 --- modulename: codecs, funcname: __init__
codecs.py(194):         self.errors = errors
codecs.py(195):         self.buffer = ""
file_io.py(89):         json.dump(closest_pairs_output, f)
 --- modulename: __init__, funcname: dump
__init__.py(165):     if (not skipkeys and ensure_ascii and
__init__.py(166):         check_circular and allow_nan and
__init__.py(165):     if (not skipkeys and ensure_ascii and
__init__.py(166):         check_circular and allow_nan and
__init__.py(165):     if (not skipkeys and ensure_ascii and
__init__.py(167):         cls is None and indent is None and separators is None and
__init__.py(165):     if (not skipkeys and ensure_ascii and
__init__.py(167):         cls is None and indent is None and separators is None and
__init__.py(165):     if (not skipkeys and ensure_ascii and
__init__.py(167):         cls is None and indent is None and separators is None and
__init__.py(165):     if (not skipkeys and ensure_ascii and
__init__.py(168):         default is None and not sort_keys and not kw):
__init__.py(165):     if (not skipkeys and ensure_ascii and
__init__.py(168):         default is None and not sort_keys and not kw):
__init__.py(165):     if (not skipkeys and ensure_ascii and
__init__.py(168):         default is None and not sort_keys and not kw):
__init__.py(165):     if (not skipkeys and ensure_ascii and
__init__.py(169):         iterable = _default_encoder.iterencode(obj)
 --- modulename: encoder, funcname: iterencode
encoder.py(214):         if self.check_circular:
encoder.py(215):             markers = {}
encoder.py(218):         if self.ensure_ascii:
encoder.py(219):             _encoder = encode_basestring_ascii
encoder.py(223):         def floatstr(o, allow_nan=self.allow_nan,
encoder.py(224):                 _repr=float.__repr__, _inf=INFINITY, _neginf=-INFINITY):
encoder.py(223):         def floatstr(o, allow_nan=self.allow_nan,
encoder.py(246):         if (_one_shot and c_make_encoder is not None
encoder.py(253):             _iterencode = _make_iterencode(
encoder.py(254):                 markers, self.default, _encoder, self.indent, floatstr,
encoder.py(255):                 self.key_separator, self.item_separator, self.sort_keys,
encoder.py(256):                 self.skipkeys, _one_shot)
encoder.py(253):             _iterencode = _make_iterencode(
 --- modulename: encoder, funcname: _make_iterencode
encoder.py(274):     if _indent is not None and not isinstance(_indent, str):
encoder.py(277):     def _iterencode_list(lst, _current_indent_level):
encoder.py(333):     def _iterencode_dict(dct, _current_indent_level):
encoder.py(413):     def _iterencode(o, _current_indent_level):
encoder.py(442):     return _iterencode
encoder.py(257):         return _iterencode(o, 0)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
encoder.py(414):         if isinstance(o, str):
encoder.py(416):         elif o is None:
encoder.py(418):         elif o is True:
encoder.py(420):         elif o is False:
encoder.py(422):         elif isinstance(o, int):
encoder.py(425):         elif isinstance(o, float):
encoder.py(428):         elif isinstance(o, (list, tuple)):
encoder.py(429):             yield from _iterencode_list(o, _current_indent_level)
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(278):         if not lst:
encoder.py(281):         if markers is not None:
encoder.py(282):             markerid = id(lst)
encoder.py(283):             if markerid in markers:
encoder.py(285):             markers[markerid] = lst
encoder.py(286):         buf = '['
encoder.py(287):         if _indent is not None:
encoder.py(293):             newline_indent = None
encoder.py(294):             separator = _item_separator
encoder.py(295):         first = True
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(298):                 first = False
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(314):             elif isinstance(value, float):
encoder.py(318):                 yield buf
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(319):                 if isinstance(value, (list, tuple)):
encoder.py(321):                 elif isinstance(value, dict):
encoder.py(322):                     chunks = _iterencode_dict(value, _current_indent_level)
encoder.py(325):                 yield from chunks
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(334):         if not dct:
encoder.py(337):         if markers is not None:
encoder.py(338):             markerid = id(dct)
encoder.py(339):             if markerid in markers:
encoder.py(341):             markers[markerid] = dct
encoder.py(342):         yield '{'
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(343):         if _indent is not None:
encoder.py(349):             newline_indent = None
encoder.py(350):             item_separator = _item_separator
encoder.py(351):         first = True
encoder.py(352):         if _sort_keys:
encoder.py(355):             items = dct.items()
encoder.py(356):         for key, value in items:
encoder.py(357):             if isinstance(key, str):
encoder.py(358):                 pass
encoder.py(378):             if first:
encoder.py(379):                 first = False
encoder.py(382):             yield _encoder(key)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(383):             yield _key_separator
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(384):             if isinstance(value, str):
encoder.py(386):             elif value is None:
encoder.py(388):             elif value is True:
encoder.py(390):             elif value is False:
encoder.py(392):             elif isinstance(value, int):
encoder.py(394):                 yield _intstr(value)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(356):         for key, value in items:
encoder.py(357):             if isinstance(key, str):
encoder.py(358):                 pass
encoder.py(378):             if first:
encoder.py(381):                 yield item_separator
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(382):             yield _encoder(key)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(383):             yield _key_separator
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(384):             if isinstance(value, str):
encoder.py(386):             elif value is None:
encoder.py(388):             elif value is True:
encoder.py(390):             elif value is False:
encoder.py(392):             elif isinstance(value, int):
encoder.py(394):                 yield _intstr(value)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(356):         for key, value in items:
encoder.py(357):             if isinstance(key, str):
encoder.py(358):                 pass
encoder.py(378):             if first:
encoder.py(381):                 yield item_separator
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(382):             yield _encoder(key)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(383):             yield _key_separator
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(384):             if isinstance(value, str):
encoder.py(386):             elif value is None:
encoder.py(388):             elif value is True:
encoder.py(390):             elif value is False:
encoder.py(392):             elif isinstance(value, int):
encoder.py(395):             elif isinstance(value, float):
encoder.py(399):                 if isinstance(value, (list, tuple)):
encoder.py(400):                     chunks = _iterencode_list(value, _current_indent_level)
encoder.py(405):                 yield from chunks
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(278):         if not lst:
encoder.py(281):         if markers is not None:
encoder.py(282):             markerid = id(lst)
encoder.py(283):             if markerid in markers:
encoder.py(285):             markers[markerid] = lst
encoder.py(286):         buf = '['
encoder.py(287):         if _indent is not None:
encoder.py(293):             newline_indent = None
encoder.py(294):             separator = _item_separator
encoder.py(295):         first = True
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(298):                 first = False
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(314):             elif isinstance(value, float):
encoder.py(318):                 yield buf
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(319):                 if isinstance(value, (list, tuple)):
encoder.py(320):                     chunks = _iterencode_list(value, _current_indent_level)
encoder.py(325):                 yield from chunks
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(278):         if not lst:
encoder.py(281):         if markers is not None:
encoder.py(282):             markerid = id(lst)
encoder.py(283):             if markerid in markers:
encoder.py(285):             markers[markerid] = lst
encoder.py(286):         buf = '['
encoder.py(287):         if _indent is not None:
encoder.py(293):             newline_indent = None
encoder.py(294):             separator = _item_separator
encoder.py(295):         first = True
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(298):                 first = False
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(314):             elif isinstance(value, float):
encoder.py(318):                 yield buf
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(319):                 if isinstance(value, (list, tuple)):
encoder.py(320):                     chunks = _iterencode_list(value, _current_indent_level)
encoder.py(325):                 yield from chunks
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(278):         if not lst:
encoder.py(281):         if markers is not None:
encoder.py(282):             markerid = id(lst)
encoder.py(283):             if markerid in markers:
encoder.py(285):             markers[markerid] = lst
encoder.py(286):         buf = '['
encoder.py(287):         if _indent is not None:
encoder.py(293):             newline_indent = None
encoder.py(294):             separator = _item_separator
encoder.py(295):         first = True
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(298):                 first = False
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(313):                 yield buf + _intstr(value)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(300):                 buf = separator
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(313):                 yield buf + _intstr(value)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(296):         for value in lst:
encoder.py(326):         if newline_indent is not None:
encoder.py(329):         yield ']'
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(330):         if markers is not None:
encoder.py(331):             del markers[markerid]
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(300):                 buf = separator
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(314):             elif isinstance(value, float):
encoder.py(318):                 yield buf
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(319):                 if isinstance(value, (list, tuple)):
encoder.py(320):                     chunks = _iterencode_list(value, _current_indent_level)
encoder.py(325):                 yield from chunks
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(278):         if not lst:
encoder.py(281):         if markers is not None:
encoder.py(282):             markerid = id(lst)
encoder.py(283):             if markerid in markers:
encoder.py(285):             markers[markerid] = lst
encoder.py(286):         buf = '['
encoder.py(287):         if _indent is not None:
encoder.py(293):             newline_indent = None
encoder.py(294):             separator = _item_separator
encoder.py(295):         first = True
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(298):                 first = False
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(313):                 yield buf + _intstr(value)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(300):                 buf = separator
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(313):                 yield buf + _intstr(value)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(296):         for value in lst:
encoder.py(326):         if newline_indent is not None:
encoder.py(329):         yield ']'
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(330):         if markers is not None:
encoder.py(331):             del markers[markerid]
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(300):                 buf = separator
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(314):             elif isinstance(value, float):
encoder.py(316):                 yield buf + _floatstr(value)
 --- modulename: encoder, funcname: floatstr
encoder.py(229):             if o != o:
encoder.py(231):             elif o == _inf:
encoder.py(233):             elif o == _neginf:
encoder.py(236):                 return _repr(o)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(296):         for value in lst:
encoder.py(326):         if newline_indent is not None:
encoder.py(329):         yield ']'
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(330):         if markers is not None:
encoder.py(331):             del markers[markerid]
encoder.py(296):         for value in lst:
encoder.py(326):         if newline_indent is not None:
encoder.py(329):         yield ']'
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(330):         if markers is not None:
encoder.py(331):             del markers[markerid]
encoder.py(356):         for key, value in items:
encoder.py(357):             if isinstance(key, str):
encoder.py(358):                 pass
encoder.py(378):             if first:
encoder.py(381):                 yield item_separator
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(382):             yield _encoder(key)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(383):             yield _key_separator
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(384):             if isinstance(value, str):
encoder.py(386):             elif value is None:
encoder.py(388):             elif value is True:
encoder.py(390):             elif value is False:
encoder.py(392):             elif isinstance(value, int):
encoder.py(395):             elif isinstance(value, float):
encoder.py(399):                 if isinstance(value, (list, tuple)):
encoder.py(400):                     chunks = _iterencode_list(value, _current_indent_level)
encoder.py(405):                 yield from chunks
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(278):         if not lst:
encoder.py(281):         if markers is not None:
encoder.py(282):             markerid = id(lst)
encoder.py(283):             if markerid in markers:
encoder.py(285):             markers[markerid] = lst
encoder.py(286):         buf = '['
encoder.py(287):         if _indent is not None:
encoder.py(293):             newline_indent = None
encoder.py(294):             separator = _item_separator
encoder.py(295):         first = True
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(298):                 first = False
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(314):             elif isinstance(value, float):
encoder.py(318):                 yield buf
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(319):                 if isinstance(value, (list, tuple)):
encoder.py(320):                     chunks = _iterencode_list(value, _current_indent_level)
encoder.py(325):                 yield from chunks
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(278):         if not lst:
encoder.py(281):         if markers is not None:
encoder.py(282):             markerid = id(lst)
encoder.py(283):             if markerid in markers:
encoder.py(285):             markers[markerid] = lst
encoder.py(286):         buf = '['
encoder.py(287):         if _indent is not None:
encoder.py(293):             newline_indent = None
encoder.py(294):             separator = _item_separator
encoder.py(295):         first = True
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(298):                 first = False
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(313):                 yield buf + _intstr(value)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(300):                 buf = separator
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(313):                 yield buf + _intstr(value)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(296):         for value in lst:
encoder.py(326):         if newline_indent is not None:
encoder.py(329):         yield ']'
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(330):         if markers is not None:
encoder.py(331):             del markers[markerid]
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(300):                 buf = separator
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(314):             elif isinstance(value, float):
encoder.py(318):                 yield buf
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(319):                 if isinstance(value, (list, tuple)):
encoder.py(320):                     chunks = _iterencode_list(value, _current_indent_level)
encoder.py(325):                 yield from chunks
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(278):         if not lst:
encoder.py(281):         if markers is not None:
encoder.py(282):             markerid = id(lst)
encoder.py(283):             if markerid in markers:
encoder.py(285):             markers[markerid] = lst
encoder.py(286):         buf = '['
encoder.py(287):         if _indent is not None:
encoder.py(293):             newline_indent = None
encoder.py(294):             separator = _item_separator
encoder.py(295):         first = True
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(298):                 first = False
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(313):                 yield buf + _intstr(value)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(296):         for value in lst:
encoder.py(297):             if first:
encoder.py(300):                 buf = separator
encoder.py(301):             if isinstance(value, str):
encoder.py(303):             elif value is None:
encoder.py(305):             elif value is True:
encoder.py(307):             elif value is False:
encoder.py(309):             elif isinstance(value, int):
encoder.py(313):                 yield buf + _intstr(value)
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(296):         for value in lst:
encoder.py(326):         if newline_indent is not None:
encoder.py(329):         yield ']'
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(330):         if markers is not None:
encoder.py(331):             del markers[markerid]
encoder.py(296):         for value in lst:
encoder.py(326):         if newline_indent is not None:
encoder.py(329):         yield ']'
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(330):         if markers is not None:
encoder.py(331):             del markers[markerid]
encoder.py(356):         for key, value in items:
encoder.py(406):         if newline_indent is not None:
encoder.py(409):         yield '}'
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
 --- modulename: encoder, funcname: _iterencode_dict
encoder.py(410):         if markers is not None:
encoder.py(411):             del markers[markerid]
encoder.py(296):         for value in lst:
encoder.py(326):         if newline_indent is not None:
encoder.py(329):         yield ']'
__init__.py(180):         fp.write(chunk)
__init__.py(179):     for chunk in iterable:
 --- modulename: encoder, funcname: _iterencode
 --- modulename: encoder, funcname: _iterencode_list
encoder.py(330):         if markers is not None:
encoder.py(331):             del markers[markerid]
run.py(86):     logging.debug("Finish.\n")
 --- modulename: __init__, funcname: debug
__init__.py(2090):     if len(root.handlers) == 0:
__init__.py(2092):     root.debug(msg, *args, **kwargs)
 --- modulename: __init__, funcname: debug
__init__.py(1433):         if self.isEnabledFor(DEBUG):
 --- modulename: __init__, funcname: isEnabledFor
__init__.py(1693):         if self.disabled:
__init__.py(1696):         try:
__init__.py(1697):             return self._cache[level]
__init__.py(1434):             self._log(DEBUG, msg, args, **kwargs)
 --- modulename: __init__, funcname: _log
__init__.py(1571):         sinfo = None
__init__.py(1572):         if _srcfile:
__init__.py(1576):             try:
__init__.py(1577):                 fn, lno, func, sinfo = self.findCaller(stack_info, stacklevel)
 --- modulename: __init__, funcname: findCaller
__init__.py(1519):         f = currentframe()
 --- modulename: __init__, funcname: <lambda>
__init__.py(160):     currentframe = lambda: sys._getframe(3)
__init__.py(1522):         if f is not None:
__init__.py(1523):             f = f.f_back
__init__.py(1524):         orig_f = f
__init__.py(1525):         while f and stacklevel > 1:
__init__.py(1528):         if not f:
__init__.py(1530):         rv = "(unknown file)", 0, "(unknown function)", None
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1535):                 f = f.f_back
__init__.py(1536):                 continue
__init__.py(1531):         while hasattr(f, "f_code"):
__init__.py(1532):             co = f.f_code
__init__.py(1533):             filename = os.path.normcase(co.co_filename)
 --- modulename: posixpath, funcname: normcase
posixpath.py(54):     return os.fspath(s)
__init__.py(1534):             if filename == _srcfile:
__init__.py(1537):             sinfo = None
__init__.py(1538):             if stack_info:
__init__.py(1546):             rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)
__init__.py(1547):             break
__init__.py(1548):         return rv
__init__.py(1582):         if exc_info:
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
__init__.py(1588):                                  exc_info, func, extra, sinfo)
__init__.py(1587):         record = self.makeRecord(self.name, level, fn, lno, msg, args,
 --- modulename: __init__, funcname: makeRecord
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
__init__.py(1557):                              sinfo)
__init__.py(1556):         rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
 --- modulename: __init__, funcname: __init__
__init__.py(293):         ct = time.time()
__init__.py(294):         self.name = name
__init__.py(295):         self.msg = msg
__init__.py(314):         if (args and len(args) == 1 and isinstance(args[0], collections.abc.Mapping)
__init__.py(317):         self.args = args
__init__.py(318):         self.levelname = getLevelName(level)
 --- modulename: __init__, funcname: getLevelName
__init__.py(138):     result = _levelToName.get(level)
__init__.py(139):     if result is not None:
__init__.py(140):         return result
__init__.py(319):         self.levelno = level
__init__.py(320):         self.pathname = pathname
__init__.py(321):         try:
__init__.py(322):             self.filename = os.path.basename(pathname)
 --- modulename: posixpath, funcname: basename
posixpath.py(142):     p = os.fspath(p)
posixpath.py(143):     sep = _get_sep(p)
 --- modulename: posixpath, funcname: _get_sep
posixpath.py(42):     if isinstance(path, bytes):
posixpath.py(45):         return '/'
posixpath.py(144):     i = p.rfind(sep) + 1
posixpath.py(145):     return p[i:]
__init__.py(323):             self.module = os.path.splitext(self.filename)[0]
 --- modulename: posixpath, funcname: splitext
posixpath.py(118):     p = os.fspath(p)
posixpath.py(119):     if isinstance(p, bytes):
posixpath.py(123):         sep = '/'
posixpath.py(124):         extsep = '.'
posixpath.py(125):     return genericpath._splitext(p, sep, None, extsep)
 --- modulename: genericpath, funcname: _splitext
genericpath.py(128):     sepIndex = p.rfind(sep)
genericpath.py(129):     if altsep:
genericpath.py(133):     dotIndex = p.rfind(extsep)
genericpath.py(134):     if dotIndex > sepIndex:
genericpath.py(136):         filenameIndex = sepIndex + 1
genericpath.py(137):         while filenameIndex < dotIndex:
genericpath.py(138):             if p[filenameIndex:filenameIndex+1] != extsep:
genericpath.py(139):                 return p[:dotIndex], p[dotIndex:]
__init__.py(327):         self.exc_info = exc_info
__init__.py(328):         self.exc_text = None      # used to cache the traceback text
__init__.py(329):         self.stack_info = sinfo
__init__.py(330):         self.lineno = lineno
__init__.py(331):         self.funcName = func
__init__.py(332):         self.created = ct
__init__.py(333):         self.msecs = (ct - int(ct)) * 1000
__init__.py(334):         self.relativeCreated = (self.created - _startTime) * 1000
__init__.py(335):         if logThreads:
__init__.py(336):             self.thread = threading.get_ident()
__init__.py(337):             self.threadName = threading.current_thread().name
 --- modulename: threading, funcname: current_thread
threading.py(1313):     try:
threading.py(1314):         return _active[get_ident()]
 --- modulename: threading, funcname: name
threading.py(1039):         assert self._initialized, "Thread.__init__() not called"
threading.py(1040):         return self._name
__init__.py(341):         if not logMultiprocessing: # pragma: no cover
__init__.py(344):             self.processName = 'MainProcess'
__init__.py(345):             mp = sys.modules.get('multiprocessing')
__init__.py(346):             if mp is not None:
__init__.py(355):         if logProcesses and hasattr(os, 'getpid'):
__init__.py(356):             self.process = os.getpid()
__init__.py(1558):         if extra is not None:
__init__.py(1563):         return rv
__init__.py(1589):         self.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(1598):         if (not self.disabled) and self.filter(record):
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(1599):             self.callHandlers(record)
 --- modulename: __init__, funcname: callHandlers
__init__.py(1655):         c = self
__init__.py(1656):         found = 0
__init__.py(1657):         while c:
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1659):                 found = found + 1
__init__.py(1660):                 if record.levelno >= hdlr.level:
__init__.py(1661):                     hdlr.handle(record)
 --- modulename: __init__, funcname: handle
__init__.py(950):         rv = self.filter(record)
 --- modulename: __init__, funcname: filter
__init__.py(808):         rv = True
__init__.py(809):         for f in self.filters:
__init__.py(817):         return rv
__init__.py(951):         if rv:
__init__.py(952):             self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(953):             try:
__init__.py(954):                 self.emit(record)
 --- modulename: __init__, funcname: emit
__init__.py(1185):         if self.stream is None:
__init__.py(1187):         StreamHandler.emit(self, record)
 --- modulename: __init__, funcname: emit
__init__.py(1084):         try:
__init__.py(1085):             msg = self.format(record)
 --- modulename: __init__, funcname: format
__init__.py(925):         if self.formatter:
__init__.py(926):             fmt = self.formatter
__init__.py(929):         return fmt.format(record)
 --- modulename: __init__, funcname: format
__init__.py(668):         record.message = record.getMessage()
 --- modulename: __init__, funcname: getMessage
__init__.py(371):         msg = str(self.msg)
__init__.py(372):         if self.args:
__init__.py(374):         return msg
__init__.py(669):         if self.usesTime():
 --- modulename: __init__, funcname: usesTime
__init__.py(637):         return self._style.usesTime()
 --- modulename: __init__, funcname: usesTime
__init__.py(428):         return self._fmt.find(self.asctime_search) >= 0
__init__.py(670):             record.asctime = self.formatTime(record, self.datefmt)
 --- modulename: __init__, funcname: formatTime
__init__.py(606):         ct = self.converter(record.created)
__init__.py(607):         if datefmt:
__init__.py(610):             t = time.strftime(self.default_time_format, ct)
__init__.py(611):             s = self.default_msec_format % (t, record.msecs)
__init__.py(612):         return s
__init__.py(671):         s = self.formatMessage(record)
 --- modulename: __init__, funcname: formatMessage
__init__.py(640):         return self._style.format(record)
 --- modulename: __init__, funcname: format
__init__.py(439):         try:
__init__.py(440):             return self._format(record)
 --- modulename: __init__, funcname: _format
__init__.py(436):         return self._fmt % record.__dict__
__init__.py(672):         if record.exc_info:
__init__.py(677):         if record.exc_text:
__init__.py(681):         if record.stack_info:
__init__.py(685):         return s
__init__.py(1086):             stream = self.stream
__init__.py(1088):             stream.write(msg + self.terminator)
__init__.py(1089):             self.flush()
 --- modulename: __init__, funcname: flush
__init__.py(1066):         self.acquire()
 --- modulename: __init__, funcname: acquire
__init__.py(902):         if self.lock:
__init__.py(903):             self.lock.acquire()
__init__.py(1067):         try:
__init__.py(1068):             if self.stream and hasattr(self.stream, "flush"):
__init__.py(1069):                 self.stream.flush()
__init__.py(1071):             self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(956):                 self.release()
 --- modulename: __init__, funcname: release
__init__.py(909):         if self.lock:
__init__.py(910):             self.lock.release()
__init__.py(957):         return rv
__init__.py(1658):             for hdlr in c.handlers:
__init__.py(1662):             if not c.propagate:
__init__.py(1665):                 c = c.parent
__init__.py(1657):         while c:
__init__.py(1666):         if (found == 0):
